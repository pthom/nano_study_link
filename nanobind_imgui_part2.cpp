// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2024 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>


namespace nb = nanobind;


#include "imgui.h"
#include "imgui_internal.h"

using uint = unsigned int;
using uchar = unsigned char;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void nanobind_imgui_part2(nb::module_& m)
{
    auto pyClassImVector_int =
        nb::class_<ImVector<int>>
            (m, "ImVector_int", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<int>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<int> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<int>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<int>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<int>::empty, "(private API)")
        .def("size",
            &ImVector<int>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<int>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<int>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<int>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<int>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<int>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<int> &v) {
                return nb::make_iterator(nb::type<ImVector<int>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<int> &v) { return v.size(); })
        ;
    auto pyClassImVector_uint =
        nb::class_<ImVector<uint>>
            (m, "ImVector_uint", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<uint>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<uint> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<uint>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<uint>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<uint>::empty, "(private API)")
        .def("size",
            &ImVector<uint>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uint>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uint>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<uint>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<uint>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<uint>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<uint> &v) {
                return nb::make_iterator(nb::type<ImVector<uint>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<uint> &v) { return v.size(); })
        ;
    auto pyClassImVector_float =
        nb::class_<ImVector<float>>
            (m, "ImVector_float", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<float>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<float> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<float>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<float>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<float>::empty, "(private API)")
        .def("size",
            &ImVector<float>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<float>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<float>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<float>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<float>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<float>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<float> &v) {
                return nb::make_iterator(nb::type<ImVector<float>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<float> &v) { return v.size(); })
        ;
    auto pyClassImVector_char =
        nb::class_<ImVector<char>>
            (m, "ImVector_char", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<char>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<char> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<char>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<char>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<char>::empty, "(private API)")
        .def("size",
            &ImVector<char>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<char>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<char>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<char>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<char>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<char>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<char> &v) {
                return nb::make_iterator(nb::type<ImVector<char>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<char> &v) { return v.size(); })
        ;
    auto pyClassImVector_uchar =
        nb::class_<ImVector<uchar>>
            (m, "ImVector_uchar", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<uchar>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<uchar> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<uchar>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<uchar>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<uchar>::empty, "(private API)")
        .def("size",
            &ImVector<uchar>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uchar>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uchar>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<uchar>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<uchar>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<uchar>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<uchar> &v) {
                return nb::make_iterator(nb::type<ImVector<uchar>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<uchar> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawCmd =
        nb::class_<ImVector<ImDrawCmd>>
            (m, "ImVector_ImDrawCmd", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawCmd>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawCmd> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawCmd>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawCmd>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawCmd>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawCmd>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawCmd>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawCmd>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawCmd>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawCmd>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawCmd>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawCmd> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawCmd>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawCmd> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawChannel =
        nb::class_<ImVector<ImDrawChannel>>
            (m, "ImVector_ImDrawChannel", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawChannel>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawChannel> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawChannel>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawChannel>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawChannel>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawChannel>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawChannel>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawChannel>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawChannel>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawChannel>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawChannel>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawChannel> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawChannel>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawChannel> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawVert =
        nb::class_<ImVector<ImDrawVert>>
            (m, "ImVector_ImDrawVert", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawVert>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawVert> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawVert>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawVert>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawVert>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawVert>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawVert>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawVert>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawVert>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawVert>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawVert>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawVert> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawVert>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawVert> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImVec4 =
        nb::class_<ImVector<ImVec4>>
            (m, "ImVector_ImVec4", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImVec4>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImVec4> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImVec4>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImVec4>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImVec4>::empty, "(private API)")
        .def("size",
            &ImVector<ImVec4>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec4>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec4>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImVec4>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImVec4>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImVec4>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImVec4> &v) {
                return nb::make_iterator(nb::type<ImVector<ImVec4>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImVec4> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImVec2 =
        nb::class_<ImVector<ImVec2>>
            (m, "ImVector_ImVec2", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImVec2>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImVec2> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImVec2>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImVec2>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImVec2>::empty, "(private API)")
        .def("size",
            &ImVector<ImVec2>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec2>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec2>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImVec2>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImVec2>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImVec2>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImVec2> &v) {
                return nb::make_iterator(nb::type<ImVector<ImVec2>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImVec2> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawList_ptr =
        nb::class_<ImVector<ImDrawList *>>
            (m, "ImVector_ImDrawList_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawList *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawList *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawList *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawList *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawList *>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawList *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawList *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawList *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawList *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawList *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawList *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawList *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawList *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawList *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFont_ptr =
        nb::class_<ImVector<ImFont *>>
            (m, "ImVector_ImFont_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFont *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFont *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFont *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFont *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFont *>::empty, "(private API)")
        .def("size",
            &ImVector<ImFont *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFont *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFont *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFont *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFont *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFont *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFont *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFont *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFont *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFontGlyph =
        nb::class_<ImVector<ImFontGlyph>>
            (m, "ImVector_ImFontGlyph", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFontGlyph>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFontGlyph> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFontGlyph>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFontGlyph>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFontGlyph>::empty, "(private API)")
        .def("size",
            &ImVector<ImFontGlyph>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontGlyph>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontGlyph>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFontGlyph>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFontGlyph>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFontGlyph>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFontGlyph> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFontGlyph>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFontGlyph> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiPlatformMonitor =
        nb::class_<ImVector<ImGuiPlatformMonitor>>
            (m, "ImVector_PlatformMonitor", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiPlatformMonitor>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiPlatformMonitor> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiPlatformMonitor>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiPlatformMonitor>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiPlatformMonitor>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiPlatformMonitor>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPlatformMonitor>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPlatformMonitor>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiPlatformMonitor>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiPlatformMonitor>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiPlatformMonitor>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiPlatformMonitor> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiPlatformMonitor>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiPlatformMonitor> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiViewport_ptr =
        nb::class_<ImVector<ImGuiViewport *>>
            (m, "ImVector_Viewport_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiViewport *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiViewport *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiViewport *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiViewport *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiViewport *>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiViewport *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewport *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewport *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiViewport *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiViewport *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiViewport *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiViewport *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiViewport *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiViewport *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiWindow_ptr =
        nb::class_<ImVector<ImGuiWindow *>>
            (m, "ImVector_Window_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiWindow *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiWindow *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiWindow *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiWindow *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiWindow *>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiWindow *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindow *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindow *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiWindow *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiWindow *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiWindow *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiWindow *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiWindow *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiWindow *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFontAtlasCustomRect =
        nb::class_<ImVector<ImFontAtlasCustomRect>>
            (m, "ImVector_ImFontAtlasCustomRect", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFontAtlasCustomRect>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFontAtlasCustomRect> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFontAtlasCustomRect>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFontAtlasCustomRect>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFontAtlasCustomRect>::empty, "(private API)")
        .def("size",
            &ImVector<ImFontAtlasCustomRect>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontAtlasCustomRect>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontAtlasCustomRect>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFontAtlasCustomRect>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFontAtlasCustomRect>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFontAtlasCustomRect>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFontAtlasCustomRect> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFontAtlasCustomRect>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFontAtlasCustomRect> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFontConfig =
        nb::class_<ImVector<ImFontConfig>>
            (m, "ImVector_ImFontConfig", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFontConfig>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFontConfig> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFontConfig>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFontConfig>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFontConfig>::empty, "(private API)")
        .def("size",
            &ImVector<ImFontConfig>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontConfig>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontConfig>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFontConfig>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFontConfig>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFontConfig>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFontConfig> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFontConfig>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFontConfig> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiFocusScopeData =
        nb::class_<ImVector<ImGuiFocusScopeData>>
            (m, "ImVector_FocusScopeData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiFocusScopeData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiFocusScopeData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiFocusScopeData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiFocusScopeData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiFocusScopeData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiFocusScopeData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiFocusScopeData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiFocusScopeData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiFocusScopeData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiFocusScopeData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiFocusScopeData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiFocusScopeData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiFocusScopeData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiFocusScopeData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiSelectionRequest =
        nb::class_<ImVector<ImGuiSelectionRequest>>
            (m, "ImVector_SelectionRequest", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiSelectionRequest>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiSelectionRequest> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiSelectionRequest>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiSelectionRequest>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiSelectionRequest>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiSelectionRequest>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSelectionRequest>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSelectionRequest>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiSelectionRequest>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiSelectionRequest>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiSelectionRequest>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiSelectionRequest> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiSelectionRequest>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiSelectionRequest> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImRect =
        nb::class_<ImVector<ImRect>>
            (m, "ImVector_ImRect", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImRect>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImRect> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImRect>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImRect>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImRect>::empty, "(private API)")
        .def("size",
            &ImVector<ImRect>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImRect>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImRect>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImRect>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImRect>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImRect>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImRect> &v) {
                return nb::make_iterator(nb::type<ImVector<ImRect>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImRect> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiColorMod =
        nb::class_<ImVector<ImGuiColorMod>>
            (m, "ImVector_ColorMod", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiColorMod>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiColorMod> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiColorMod>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiColorMod>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiColorMod>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiColorMod>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiColorMod>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiColorMod>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiColorMod>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiColorMod>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiColorMod>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiColorMod> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiColorMod>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiColorMod> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiGroupData =
        nb::class_<ImVector<ImGuiGroupData>>
            (m, "ImVector_GroupData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiGroupData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiGroupData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiGroupData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiGroupData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiGroupData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiGroupData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiGroupData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiGroupData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiGroupData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiGroupData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiGroupData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiGroupData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiGroupData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiGroupData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiPopupData =
        nb::class_<ImVector<ImGuiPopupData>>
            (m, "ImVector_PopupData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiPopupData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiPopupData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiPopupData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiPopupData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiPopupData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiPopupData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPopupData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPopupData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiPopupData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiPopupData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiPopupData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiPopupData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiPopupData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiPopupData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiViewportP_ptr =
        nb::class_<ImVector<ImGuiViewportP *>>
            (m, "ImVector_ViewportP_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiViewportP *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiViewportP *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiViewportP *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiViewportP *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiViewportP *>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiViewportP *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewportP *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewportP *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiViewportP *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiViewportP *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiViewportP *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiViewportP *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiViewportP *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiViewportP *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiInputEvent =
        nb::class_<ImVector<ImGuiInputEvent>>
            (m, "ImVector_InputEvent", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiInputEvent>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiInputEvent> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiInputEvent>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiInputEvent>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiInputEvent>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiInputEvent>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiInputEvent>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiInputEvent>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiInputEvent>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiInputEvent>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiInputEvent>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiInputEvent> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiInputEvent>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiInputEvent> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiWindowStackData =
        nb::class_<ImVector<ImGuiWindowStackData>>
            (m, "ImVector_WindowStackData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiWindowStackData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiWindowStackData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiWindowStackData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiWindowStackData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiWindowStackData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiWindowStackData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindowStackData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindowStackData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiWindowStackData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiWindowStackData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiWindowStackData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiWindowStackData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiWindowStackData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiWindowStackData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableColumnSortSpecs =
        nb::class_<ImVector<ImGuiTableColumnSortSpecs>>
            (m, "ImVector_TableColumnSortSpecs", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableColumnSortSpecs>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableColumnSortSpecs> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableColumnSortSpecs>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableColumnSortSpecs>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableColumnSortSpecs>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableColumnSortSpecs>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableColumnSortSpecs>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableColumnSortSpecs>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableColumnSortSpecs>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableColumnSortSpecs>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableColumnSortSpecs>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableColumnSortSpecs> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableColumnSortSpecs>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableColumnSortSpecs> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableInstanceData =
        nb::class_<ImVector<ImGuiTableInstanceData>>
            (m, "ImVector_TableInstanceData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableInstanceData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableInstanceData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableInstanceData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableInstanceData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableInstanceData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableInstanceData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableInstanceData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableInstanceData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableInstanceData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableInstanceData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableInstanceData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableInstanceData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableInstanceData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableInstanceData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableTempData =
        nb::class_<ImVector<ImGuiTableTempData>>
            (m, "ImVector_TableTempData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableTempData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableTempData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableTempData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableTempData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableTempData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableTempData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableTempData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableTempData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableTempData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableTempData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableTempData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableTempData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableTempData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableTempData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiPtrOrIndex =
        nb::class_<ImVector<ImGuiPtrOrIndex>>
            (m, "ImVector_PtrOrIndex", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiPtrOrIndex>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiPtrOrIndex> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiPtrOrIndex>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiPtrOrIndex>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiPtrOrIndex>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiPtrOrIndex>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPtrOrIndex>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPtrOrIndex>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiPtrOrIndex>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiPtrOrIndex>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiPtrOrIndex>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiPtrOrIndex> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiPtrOrIndex>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiPtrOrIndex> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiSettingsHandler =
        nb::class_<ImVector<ImGuiSettingsHandler>>
            (m, "ImVector_SettingsHandler", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiSettingsHandler>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiSettingsHandler> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiSettingsHandler>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiSettingsHandler>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiSettingsHandler>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiSettingsHandler>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSettingsHandler>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSettingsHandler>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiSettingsHandler>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiSettingsHandler>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiSettingsHandler>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiSettingsHandler> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiSettingsHandler>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiSettingsHandler> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiShrinkWidthItem =
        nb::class_<ImVector<ImGuiShrinkWidthItem>>
            (m, "ImVector_ShrinkWidthItem", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiShrinkWidthItem>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiShrinkWidthItem> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiShrinkWidthItem>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiShrinkWidthItem>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiShrinkWidthItem>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiShrinkWidthItem>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiShrinkWidthItem>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiShrinkWidthItem>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiShrinkWidthItem>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiShrinkWidthItem>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiShrinkWidthItem>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiShrinkWidthItem> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiShrinkWidthItem>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiShrinkWidthItem> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiStackLevelInfo =
        nb::class_<ImVector<ImGuiStackLevelInfo>>
            (m, "ImVector_StackLevelInfo", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiStackLevelInfo>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiStackLevelInfo> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiStackLevelInfo>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiStackLevelInfo>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiStackLevelInfo>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiStackLevelInfo>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStackLevelInfo>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStackLevelInfo>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiStackLevelInfo>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiStackLevelInfo>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiStackLevelInfo>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiStackLevelInfo> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiStackLevelInfo>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiStackLevelInfo> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTabItem =
        nb::class_<ImVector<ImGuiTabItem>>
            (m, "ImVector_TabItem", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTabItem>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTabItem> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTabItem>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTabItem>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTabItem>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTabItem>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTabItem>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTabItem>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTabItem>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTabItem>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTabItem>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTabItem> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTabItem>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTabItem> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiKeyRoutingData =
        nb::class_<ImVector<ImGuiKeyRoutingData>>
            (m, "ImVector_KeyRoutingData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiKeyRoutingData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiKeyRoutingData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiKeyRoutingData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiKeyRoutingData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiKeyRoutingData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiKeyRoutingData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiKeyRoutingData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiKeyRoutingData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiKeyRoutingData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiKeyRoutingData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiKeyRoutingData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiKeyRoutingData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiKeyRoutingData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiKeyRoutingData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiListClipperData =
        nb::class_<ImVector<ImGuiListClipperData>>
            (m, "ImVector_ListClipperData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiListClipperData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiListClipperData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiListClipperData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiListClipperData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiListClipperData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiListClipperData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiListClipperData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiListClipperData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiListClipperData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiListClipperData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiListClipperData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiListClipperData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiListClipperRange =
        nb::class_<ImVector<ImGuiListClipperRange>>
            (m, "ImVector_ListClipperRange", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiListClipperRange>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiListClipperRange> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiListClipperRange>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiListClipperRange>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiListClipperRange>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiListClipperRange>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperRange>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperRange>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiListClipperRange>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiListClipperRange>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiListClipperRange>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiListClipperRange> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiListClipperRange>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiListClipperRange> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiOldColumnData =
        nb::class_<ImVector<ImGuiOldColumnData>>
            (m, "ImVector_OldColumnData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiOldColumnData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiOldColumnData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiOldColumnData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiOldColumnData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiOldColumnData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiOldColumnData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumnData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumnData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiOldColumnData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiOldColumnData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiOldColumnData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiOldColumnData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiOldColumnData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiOldColumnData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiOldColumns =
        nb::class_<ImVector<ImGuiOldColumns>>
            (m, "ImVector_OldColumns", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiOldColumns>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiOldColumns> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiOldColumns>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiOldColumns>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiOldColumns>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiOldColumns>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumns>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumns>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiOldColumns>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiOldColumns>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiOldColumns>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiOldColumns> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiOldColumns>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiOldColumns> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiStyleMod =
        nb::class_<ImVector<ImGuiStyleMod>>
            (m, "ImVector_StyleMod", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiStyleMod>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiStyleMod> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiStyleMod>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiStyleMod>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiStyleMod>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiStyleMod>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStyleMod>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStyleMod>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiStyleMod>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiStyleMod>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiStyleMod>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiStyleMod> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiStyleMod>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiStyleMod> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableHeaderData =
        nb::class_<ImVector<ImGuiTableHeaderData>>
            (m, "ImVector_TableHeaderData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableHeaderData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableHeaderData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableHeaderData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableHeaderData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableHeaderData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableHeaderData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableHeaderData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableHeaderData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableHeaderData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableHeaderData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableHeaderData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableHeaderData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableHeaderData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableHeaderData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTreeNodeStackData =
        nb::class_<ImVector<ImGuiTreeNodeStackData>>
            (m, "ImVector_TreeNodeStackData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTreeNodeStackData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTreeNodeStackData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTreeNodeStackData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTreeNodeStackData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTreeNodeStackData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTreeNodeStackData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTreeNodeStackData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTreeNodeStackData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTreeNodeStackData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTreeNodeStackData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTreeNodeStackData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTreeNodeStackData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTreeNodeStackData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTreeNodeStackData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiMultiSelectTempData =
        nb::class_<ImVector<ImGuiMultiSelectTempData>>
            (m, "ImVector_MultiSelectTempData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiMultiSelectTempData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiMultiSelectTempData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiMultiSelectTempData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiMultiSelectTempData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiMultiSelectTempData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiMultiSelectTempData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiMultiSelectTempData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiMultiSelectTempData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiMultiSelectTempData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiMultiSelectTempData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiMultiSelectTempData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiMultiSelectTempData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiMultiSelectTempData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiMultiSelectTempData> &v) { return v.size(); })
        ;
}
