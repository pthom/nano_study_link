// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2024 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>


namespace nb = nanobind;


#include "imgui.h"
#include "imgui_internal.h"

using uint = unsigned int;
using uchar = unsigned char;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void nanobind_imgui_part3(nb::module_& m)
{
    auto pyClassImGuiStyle =
        nb::class_<ImGuiStyle>
            (m, "Style", "")
        .def_rw("alpha", &ImGuiStyle::Alpha, "Global alpha applies to everything in Dear ImGui.")
        .def_rw("disabled_alpha", &ImGuiStyle::DisabledAlpha, "Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.")
        .def_rw("window_padding", &ImGuiStyle::WindowPadding, "Padding within a window.")
        .def_rw("window_rounding", &ImGuiStyle::WindowRounding, "Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.")
        .def_rw("window_border_size", &ImGuiStyle::WindowBorderSize, "Thickness of border around windows. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("window_min_size", &ImGuiStyle::WindowMinSize, "Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().")
        .def_rw("window_title_align", &ImGuiStyle::WindowTitleAlign, "Alignment for title bar text. Defaults to (0.0,0.5) for left-aligned,vertically centered.")
        .def_rw("window_menu_button_position", &ImGuiStyle::WindowMenuButtonPosition, "Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.")
        .def_rw("child_rounding", &ImGuiStyle::ChildRounding, "Radius of child window corners rounding. Set to 0.0 to have rectangular windows.")
        .def_rw("child_border_size", &ImGuiStyle::ChildBorderSize, "Thickness of border around child windows. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("popup_rounding", &ImGuiStyle::PopupRounding, "Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)")
        .def_rw("popup_border_size", &ImGuiStyle::PopupBorderSize, "Thickness of border around popup/tooltip windows. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("frame_padding", &ImGuiStyle::FramePadding, "Padding within a framed rectangle (used by most widgets).")
        .def_rw("frame_rounding", &ImGuiStyle::FrameRounding, "Radius of frame corners rounding. Set to 0.0 to have rectangular frame (used by most widgets).")
        .def_rw("frame_border_size", &ImGuiStyle::FrameBorderSize, "Thickness of border around frames. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("item_spacing", &ImGuiStyle::ItemSpacing, "Horizontal and vertical spacing between widgets/lines.")
        .def_rw("item_inner_spacing", &ImGuiStyle::ItemInnerSpacing, "Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).")
        .def_rw("cell_padding", &ImGuiStyle::CellPadding, "Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.")
        .def_rw("touch_extra_padding", &ImGuiStyle::TouchExtraPadding, "Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!")
        .def_rw("indent_spacing", &ImGuiStyle::IndentSpacing, "Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).")
        .def_rw("columns_min_spacing", &ImGuiStyle::ColumnsMinSpacing, "Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).")
        .def_rw("scrollbar_size", &ImGuiStyle::ScrollbarSize, "Width of the vertical scrollbar, Height of the horizontal scrollbar.")
        .def_rw("scrollbar_rounding", &ImGuiStyle::ScrollbarRounding, "Radius of grab corners for scrollbar.")
        .def_rw("grab_min_size", &ImGuiStyle::GrabMinSize, "Minimum width/height of a grab box for slider/scrollbar.")
        .def_rw("grab_rounding", &ImGuiStyle::GrabRounding, "Radius of grabs corners rounding. Set to 0.0 to have rectangular slider grabs.")
        .def_rw("layout_align", &ImGuiStyle::LayoutAlign, "Element alignment inside horizontal and vertical layouts (0.0 - left/top, 1.0 - right/bottom, 0.5 - center).")
        .def_rw("log_slider_deadzone", &ImGuiStyle::LogSliderDeadzone, "The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.")
        .def_rw("tab_rounding", &ImGuiStyle::TabRounding, "Radius of upper corners of a tab. Set to 0.0 to have rectangular tabs.")
        .def_rw("tab_border_size", &ImGuiStyle::TabBorderSize, "Thickness of border around tabs.")
        .def_rw("tab_min_width_for_close_button", &ImGuiStyle::TabMinWidthForCloseButton, "Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0 to always show when hovering, set to FLT_MAX to never show close button unless selected.")
        .def_rw("tab_bar_border_size", &ImGuiStyle::TabBarBorderSize, "Thickness of tab-bar separator, which takes on the tab active color to denote focus.")
        .def_rw("tab_bar_overline_size", &ImGuiStyle::TabBarOverlineSize, "Thickness of tab-bar overline, which highlights the selected tab-bar.")
        .def_rw("table_angled_headers_angle", &ImGuiStyle::TableAngledHeadersAngle, "Angle of angled headers (supported values range from -50.0 degrees to +50.0 degrees).")
        .def_rw("table_angled_headers_text_align", &ImGuiStyle::TableAngledHeadersTextAlign, "Alignment of angled headers within the cell")
        .def_rw("color_button_position", &ImGuiStyle::ColorButtonPosition, "Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.")
        .def_rw("button_text_align", &ImGuiStyle::ButtonTextAlign, "Alignment of button text when button is larger than text. Defaults to (0.5, 0.5) (centered).")
        .def_rw("selectable_text_align", &ImGuiStyle::SelectableTextAlign, "Alignment of selectable text. Defaults to (0.0, 0.0) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.")
        .def_rw("separator_text_border_size", &ImGuiStyle::SeparatorTextBorderSize, "Thickness of border in SeparatorText()")
        .def_rw("separator_text_align", &ImGuiStyle::SeparatorTextAlign, "Alignment of text within the separator. Defaults to (0.0, 0.5) (left aligned, center).")
        .def_rw("separator_text_padding", &ImGuiStyle::SeparatorTextPadding, "Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.")
        .def_rw("display_window_padding", &ImGuiStyle::DisplayWindowPadding, "Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.")
        .def_rw("display_safe_area_padding", &ImGuiStyle::DisplaySafeAreaPadding, "Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).")
        .def_rw("docking_separator_size", &ImGuiStyle::DockingSeparatorSize, "Thickness of resizing border between docked windows")
        .def_rw("mouse_cursor_scale", &ImGuiStyle::MouseCursorScale, "Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.")
        .def_rw("anti_aliased_lines", &ImGuiStyle::AntiAliasedLines, "Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).")
        .def_rw("anti_aliased_lines_use_tex", &ImGuiStyle::AntiAliasedLinesUseTex, "Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).")
        .def_rw("anti_aliased_fill", &ImGuiStyle::AntiAliasedFill, "Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).")
        .def_rw("curve_tessellation_tol", &ImGuiStyle::CurveTessellationTol, "Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.")
        .def_rw("circle_tessellation_max_error", &ImGuiStyle::CircleTessellationMaxError, "Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.")
        .def_rw("hover_stationary_delay", &ImGuiStyle::HoverStationaryDelay, "Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.")
        .def_rw("hover_delay_short", &ImGuiStyle::HoverDelayShort, "Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.")
        .def_rw("hover_delay_normal", &ImGuiStyle::HoverDelayNormal, "Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). \"")
        .def_rw("hover_flags_for_tooltip_mouse", &ImGuiStyle::HoverFlagsForTooltipMouse, "Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.")
        .def_rw("hover_flags_for_tooltip_nav", &ImGuiStyle::HoverFlagsForTooltipNav, "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("color_",
            &ImGuiStyle::Color_,
            nb::arg("idx_color"),
            nb::rv_policy::reference)
        .def("set_color_",
            &ImGuiStyle::SetColor_, nb::arg("idx_color"), nb::arg("color"))
        // #endif
        //
        .def(nb::init<>())
        .def("scale_all_sizes",
            &ImGuiStyle::ScaleAllSizes, nb::arg("scale_factor"))
        ;


    auto pyClassImGuiKeyData =
        nb::class_<ImGuiKeyData>
            (m, "KeyData", " [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.\n If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.")
        .def("__init__", [](ImGuiKeyData * self, bool Down = bool(), float DownDuration = float(), float DownDurationPrev = float(), float AnalogValue = float())
        {
            new (self) ImGuiKeyData();  // placement new
            auto r = self;
            r->Down = Down;
            r->DownDuration = DownDuration;
            r->DownDurationPrev = DownDurationPrev;
            r->AnalogValue = AnalogValue;
        },
        nb::arg("down") = bool(), nb::arg("down_duration") = float(), nb::arg("down_duration_prev") = float(), nb::arg("analog_value") = float()
        )
        .def_rw("down", &ImGuiKeyData::Down, "True for if key is down")
        .def_rw("down_duration", &ImGuiKeyData::DownDuration, "Duration the key has been down (<0.0: not pressed, 0.0: just pressed, >0.0: time held)")
        .def_rw("down_duration_prev", &ImGuiKeyData::DownDurationPrev, "Last frame duration the key has been down")
        .def_rw("analog_value", &ImGuiKeyData::AnalogValue, "0.0..1.0 for gamepad values")
        ;


    auto pyClassImGuiIO =
        nb::class_<ImGuiIO>
            (m, "IO", "")
        .def_rw("config_flags", &ImGuiIO::ConfigFlags, "= 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.")
        .def_rw("backend_flags", &ImGuiIO::BackendFlags, "= 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.")
        .def_rw("display_size", &ImGuiIO::DisplaySize, "<unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.")
        .def_rw("delta_time", &ImGuiIO::DeltaTime, "= 1.0/60.0     // Time elapsed since last frame, in seconds. May change every frame.")
        .def_rw("ini_saving_rate", &ImGuiIO::IniSavingRate, "")
        .def_rw("user_data", &ImGuiIO::UserData, "= None           // Store your own data.")
        .def_rw("fonts", &ImGuiIO::Fonts, "<auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.")
        .def_rw("font_global_scale", &ImGuiIO::FontGlobalScale, "= 1.0           // Global scale all fonts")
        .def_rw("font_allow_user_scaling", &ImGuiIO::FontAllowUserScaling, "= False          // Allow user scaling text of individual window with CTRL+Wheel.")
        .def_rw("font_default", &ImGuiIO::FontDefault, "= None           // Font to use on NewFrame(). Use None to uses Fonts->Fonts[0].")
        .def_rw("display_framebuffer_scale", &ImGuiIO::DisplayFramebufferScale, "= (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.")
        .def_rw("config_nav_swap_gamepad_buttons", &ImGuiIO::ConfigNavSwapGamepadButtons, "= False          // Swap Activate<>Cancel (A<>B) buttons, matching typical \"Nintendo/Japanese style\" gamepad layout.")
        .def_rw("config_nav_move_set_mouse_pos", &ImGuiIO::ConfigNavMoveSetMousePos, "= False          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=True.")
        .def_rw("config_nav_capture_keyboard", &ImGuiIO::ConfigNavCaptureKeyboard, "= True           // Sets io.WantCaptureKeyboard when io.NavActive is set.")
        .def_rw("config_nav_escape_clear_focus_item", &ImGuiIO::ConfigNavEscapeClearFocusItem, "= True           // Pressing Escape can clear focused item + navigation id/highlight. Set to False if you want to always keep highlight on.")
        .def_rw("config_nav_escape_clear_focus_window", &ImGuiIO::ConfigNavEscapeClearFocusWindow, "= False          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).")
        .def_rw("config_nav_cursor_visible_auto", &ImGuiIO::ConfigNavCursorVisibleAuto, "= True           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.")
        .def_rw("config_nav_cursor_visible_always", &ImGuiIO::ConfigNavCursorVisibleAlways, "= False          // Navigation cursor is always visible.")
        .def_rw("config_docking_no_split", &ImGuiIO::ConfigDockingNoSplit, "= False          // Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.")
        .def_rw("config_docking_with_shift", &ImGuiIO::ConfigDockingWithShift, "= False          // Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)")
        .def_rw("config_docking_always_tab_bar", &ImGuiIO::ConfigDockingAlwaysTabBar, "= False          // [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.")
        .def_rw("config_docking_transparent_payload", &ImGuiIO::ConfigDockingTransparentPayload, "= False          // [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.")
        .def_rw("config_viewports_no_auto_merge", &ImGuiIO::ConfigViewportsNoAutoMerge, "= False;         // Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.")
        .def_rw("config_viewports_no_task_bar_icon", &ImGuiIO::ConfigViewportsNoTaskBarIcon, "= False          // Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.")
        .def_rw("config_viewports_no_decoration", &ImGuiIO::ConfigViewportsNoDecoration, "= True           // Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).")
        .def_rw("config_viewports_no_default_parent", &ImGuiIO::ConfigViewportsNoDefaultParent, "= False          // Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = <main_viewport>, expecting the platform backend to setup a parent/child relationship between the OS windows (some backend may ignore this). Set to True if you want the default to be 0, then all viewports will be top-level OS windows.")
        .def_rw("mouse_draw_cursor", &ImGuiIO::MouseDrawCursor, "= False          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.")
        .def_rw("config_mac_osx_behaviors", &ImGuiIO::ConfigMacOSXBehaviors, "= defined(__APPLE__) // Swap Cmd<>Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.")
        .def_rw("config_input_trickle_event_queue", &ImGuiIO::ConfigInputTrickleEventQueue, "= True           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.")
        .def_rw("config_input_text_cursor_blink", &ImGuiIO::ConfigInputTextCursorBlink, "= True           // Enable blinking cursor (optional as some users consider it to be distracting).")
        .def_rw("config_input_text_enter_keep_active", &ImGuiIO::ConfigInputTextEnterKeepActive, "= False          // [BETA] Pressing Enter will keep item active and select contents (single-line only).")
        .def_rw("config_drag_click_to_input_text", &ImGuiIO::ConfigDragClickToInputText, "= False          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.")
        .def_rw("config_windows_resize_from_edges", &ImGuiIO::ConfigWindowsResizeFromEdges, "= True           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)")
        .def_rw("config_windows_move_from_title_bar_only", &ImGuiIO::ConfigWindowsMoveFromTitleBarOnly, "= False      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.")
        .def_rw("config_scrollbar_scroll_by_page", &ImGuiIO::ConfigScrollbarScrollByPage, "= True           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.")
        .def_rw("config_memory_compact_timer", &ImGuiIO::ConfigMemoryCompactTimer, "= 60.0          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0 to disable.")
        .def_rw("mouse_double_click_time", &ImGuiIO::MouseDoubleClickTime, "= 0.30          // Time for a double-click, in seconds.")
        .def_rw("mouse_double_click_max_dist", &ImGuiIO::MouseDoubleClickMaxDist, "= 6.0           // Distance threshold to stay in to validate a double-click, in pixels.")
        .def_rw("mouse_drag_threshold", &ImGuiIO::MouseDragThreshold, "= 6.0           // Distance threshold before considering we are dragging.")
        .def_rw("key_repeat_delay", &ImGuiIO::KeyRepeatDelay, "= 0.275         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).")
        .def_rw("key_repeat_rate", &ImGuiIO::KeyRepeatRate, "= 0.050         // When holding a key/button, rate at which it repeats, in seconds.")
        .def_rw("config_error_recovery", &ImGuiIO::ConfigErrorRecovery, "= True       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.")
        .def_rw("config_error_recovery_enable_assert", &ImGuiIO::ConfigErrorRecoveryEnableAssert, "= True       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()")
        .def_rw("config_error_recovery_enable_debug_log", &ImGuiIO::ConfigErrorRecoveryEnableDebugLog, "= True       // Enable debug log output on recoverable errors.")
        .def_rw("config_error_recovery_enable_tooltip", &ImGuiIO::ConfigErrorRecoveryEnableTooltip, "= True       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.")
        .def_rw("config_debug_is_debugger_present", &ImGuiIO::ConfigDebugIsDebuggerPresent, "= False          // Enable various tools calling IM_DEBUG_BREAK().")
        .def_rw("config_debug_highlight_id_conflicts", &ImGuiIO::ConfigDebugHighlightIdConflicts, "= True           // Highlight and show an error message when multiple items have conflicting identifiers.")
        .def_rw("config_debug_begin_return_value_once", &ImGuiIO::ConfigDebugBeginReturnValueOnce, "= False          // First-time calls to Begin()/BeginChild() will return False. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.")
        .def_rw("config_debug_begin_return_value_loop", &ImGuiIO::ConfigDebugBeginReturnValueLoop, "= False          // Some calls to Begin()/BeginChild() will return False. Will cycle through window depths then repeat. Suggested use: add \"io.ConfigDebugBeginReturnValue = io.KeyShift\" in your main loop then occasionally press SHIFT. Windows should be flickering while running.")
        .def_rw("config_debug_ignore_focus_loss", &ImGuiIO::ConfigDebugIgnoreFocusLoss, "= False          // Ignore io.AddFocusEvent(False), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.")
        .def_rw("config_debug_ini_settings", &ImGuiIO::ConfigDebugIniSettings, "= False          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)")
        .def_ro("backend_platform_name", &ImGuiIO::BackendPlatformName, "= None")
        .def_ro("backend_renderer_name", &ImGuiIO::BackendRendererName, "= None")
        .def_rw("backend_platform_user_data", &ImGuiIO::BackendPlatformUserData, "= None           // User data for platform backend")
        .def_rw("backend_renderer_user_data", &ImGuiIO::BackendRendererUserData, "= None           // User data for renderer backend")
        .def_rw("backend_language_user_data", &ImGuiIO::BackendLanguageUserData, "= None           // User data for non C++ programming language backend")
        .def("add_key_event",
            &ImGuiIO::AddKeyEvent,
            nb::arg("key"), nb::arg("down"),
            "Queue a new key down/up event. Key should be \"translated\" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)")
        .def("add_key_analog_event",
            &ImGuiIO::AddKeyAnalogEvent,
            nb::arg("key"), nb::arg("down"), nb::arg("v"),
            "Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.")
        .def("add_mouse_pos_event",
            &ImGuiIO::AddMousePosEvent,
            nb::arg("x"), nb::arg("y"),
            "Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)")
        .def("add_mouse_button_event",
            &ImGuiIO::AddMouseButtonEvent,
            nb::arg("button"), nb::arg("down"),
            "Queue a mouse button change")
        .def("add_mouse_wheel_event",
            &ImGuiIO::AddMouseWheelEvent,
            nb::arg("wheel_x"), nb::arg("wheel_y"),
            "Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.")
        .def("add_mouse_source_event",
            &ImGuiIO::AddMouseSourceEvent,
            nb::arg("source"),
            "Queue a mouse source change (Mouse/TouchScreen/Pen)")
        .def("add_mouse_viewport_event",
            &ImGuiIO::AddMouseViewportEvent,
            nb::arg("id_"),
            "Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).")
        .def("add_focus_event",
            &ImGuiIO::AddFocusEvent,
            nb::arg("focused"),
            "Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)")
        .def("add_input_character",
            &ImGuiIO::AddInputCharacter,
            nb::arg("c"),
            "Queue a new character input")
        .def("add_input_character_utf16",
            &ImGuiIO::AddInputCharacterUTF16,
            nb::arg("c"),
            "Queue a new character input from a UTF-16 character, it can be a surrogate")
        .def("add_input_characters_utf8",
            &ImGuiIO::AddInputCharactersUTF8,
            nb::arg("str"),
            "Queue a new characters input from a UTF-8 string")
        .def("set_key_event_native_data",
            &ImGuiIO::SetKeyEventNativeData,
            nb::arg("key"), nb::arg("native_keycode"), nb::arg("native_scancode"), nb::arg("native_legacy_index") = -1,
            "[Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.")
        .def("set_app_accepting_events",
            &ImGuiIO::SetAppAcceptingEvents,
            nb::arg("accepting_events"),
            "Set master flag for accepting key/mouse/text events (default to True). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.")
        .def("clear_events_queue",
            &ImGuiIO::ClearEventsQueue, "Clear all incoming events.")
        .def("clear_input_keys",
            &ImGuiIO::ClearInputKeys, "Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.")
        .def("clear_input_mouse",
            &ImGuiIO::ClearInputMouse)
        .def_rw("want_capture_mouse", &ImGuiIO::WantCaptureMouse, "Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).")
        .def_rw("want_capture_keyboard", &ImGuiIO::WantCaptureKeyboard, "Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).")
        .def_rw("want_text_input", &ImGuiIO::WantTextInput, "Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).")
        .def_rw("want_set_mouse_pos", &ImGuiIO::WantSetMousePos, "MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.")
        .def_rw("want_save_ini_settings", &ImGuiIO::WantSaveIniSettings, "When manual .ini load/save is active (io.IniFilename == None), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!")
        .def_rw("nav_active", &ImGuiIO::NavActive, "Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.")
        .def_rw("nav_visible", &ImGuiIO::NavVisible, "Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).")
        .def_rw("framerate", &ImGuiIO::Framerate, "Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.")
        .def_rw("metrics_render_vertices", &ImGuiIO::MetricsRenderVertices, "Vertices output during last call to Render()")
        .def_rw("metrics_render_indices", &ImGuiIO::MetricsRenderIndices, "Indices output during last call to Render() = number of triangles * 3")
        .def_rw("metrics_render_windows", &ImGuiIO::MetricsRenderWindows, "Number of visible windows")
        .def_rw("metrics_active_windows", &ImGuiIO::MetricsActiveWindows, "Number of active windows")
        .def_rw("mouse_delta", &ImGuiIO::MouseDelta, "Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.")
        .def_rw("ctx", &ImGuiIO::Ctx, "Parent UI context (needs to be set explicitly by parent).")
        .def_rw("mouse_pos", &ImGuiIO::MousePos, "Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)")
        .def_prop_ro("mouse_down",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDown;
            },
            "Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.")
        .def_rw("mouse_wheel", &ImGuiIO::MouseWheel, "Mouse wheel Vertical: 1 unit scrolls about 5 lines text. >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.")
        .def_rw("mouse_wheel_h", &ImGuiIO::MouseWheelH, "Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.")
        .def_rw("mouse_source", &ImGuiIO::MouseSource, "Mouse actual input peripheral (Mouse/TouchScreen/Pen).")
        .def_rw("mouse_hovered_viewport", &ImGuiIO::MouseHoveredViewport, "(Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).")
        .def_rw("key_ctrl", &ImGuiIO::KeyCtrl, "Keyboard modifier down: Control")
        .def_rw("key_shift", &ImGuiIO::KeyShift, "Keyboard modifier down: Shift")
        .def_rw("key_alt", &ImGuiIO::KeyAlt, "Keyboard modifier down: Alt")
        .def_rw("key_super", &ImGuiIO::KeySuper, "Keyboard modifier down: Cmd/Super/Windows")
        .def_rw("key_mods", &ImGuiIO::KeyMods, "Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()")
        .def_rw("want_capture_mouse_unless_popup_close", &ImGuiIO::WantCaptureMouseUnlessPopupClose, "Alternative to WantCaptureMouse: (WantCaptureMouse == True && WantCaptureMouseUnlessPopupClose == False) when a click over None is expected to close a popup.")
        .def_rw("mouse_pos_prev", &ImGuiIO::MousePosPrev, "Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)")
        .def_prop_ro("mouse_clicked_time",
            [](ImGuiIO &self) -> nb::ndarray<double, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClickedTime;
            },
            "Time of last click (used to figure out double-click)")
        .def_prop_ro("mouse_clicked",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClicked;
            },
            "Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)")
        .def_prop_ro("mouse_double_clicked",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDoubleClicked;
            },
            "Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)")
        .def_prop_ro("mouse_clicked_count",
            [](ImGuiIO &self) -> nb::ndarray<ImU16, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClickedCount;
            },
            "== 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down")
        .def_prop_ro("mouse_clicked_last_count",
            [](ImGuiIO &self) -> nb::ndarray<ImU16, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClickedLastCount;
            },
            "Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.")
        .def_prop_ro("mouse_released",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseReleased;
            },
            "Mouse button went from Down to !Down")
        .def_prop_ro("mouse_down_owned",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownOwned;
            },
            "Track if button was clicked inside a dear imgui window or over None blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.")
        .def_prop_ro("mouse_down_owned_unless_popup_close",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownOwnedUnlessPopupClose;
            },
            "Track if button was clicked inside a dear imgui window.")
        .def_rw("mouse_wheel_request_axis_swap", &ImGuiIO::MouseWheelRequestAxisSwap, "On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.")
        .def_rw("mouse_ctrl_left_as_right_click", &ImGuiIO::MouseCtrlLeftAsRightClick, "(OSX) Set to True when the current click was a ctrl-click that spawned a simulated right click")
        .def_prop_ro("mouse_down_duration",
            [](ImGuiIO &self) -> nb::ndarray<float, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownDuration;
            },
            "Duration the mouse button has been down (0.0 == just clicked)")
        .def_prop_ro("mouse_down_duration_prev",
            [](ImGuiIO &self) -> nb::ndarray<float, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownDurationPrev;
            },
            "Previous time the mouse button has been down")
        .def_prop_ro("mouse_drag_max_distance_sqr",
            [](ImGuiIO &self) -> nb::ndarray<float, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDragMaxDistanceSqr;
            },
            "Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)")
        .def_rw("pen_pressure", &ImGuiIO::PenPressure, "Touch/Pen pressure (0.0 to 1.0, should be >0.0 only when MouseDown[0] == True). Helper storage currently unused by Dear ImGui.")
        .def_rw("app_focus_lost", &ImGuiIO::AppFocusLost, "Only modify via AddFocusEvent()")
        .def_rw("app_accepting_events", &ImGuiIO::AppAcceptingEvents, "Only modify via SetAppAcceptingEvents()")
        .def_rw("backend_using_legacy_key_arrays", &ImGuiIO::BackendUsingLegacyKeyArrays, "-1: unknown, 0: using AddKeyEvent(), 1: using legacy io.KeysDown[]")
        .def_rw("backend_using_legacy_nav_input_array", &ImGuiIO::BackendUsingLegacyNavInputArray, "0: using AddKeyAnalogEvent(), 1: writing to legacy io.NavInputs[] directly")
        .def_rw("input_queue_surrogate", &ImGuiIO::InputQueueSurrogate, "For AddInputCharacterUTF16()")
        .def_rw("input_queue_characters", &ImGuiIO::InputQueueCharacters, "")
        .def(nb::init<>())
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("set_ini_filename",
            &ImGuiIO::SetIniFilename, nb::arg("filename"))
        .def("set_log_filename",
            &ImGuiIO::SetLogFilename, nb::arg("filename"))
        .def("get_ini_filename",
            &ImGuiIO::GetIniFilename)
        .def("get_log_filename",
            &ImGuiIO::GetLogFilename)
        // #endif
        //
        ;


    auto pyClassImGuiInputTextCallbackData =
        nb::class_<ImGuiInputTextCallbackData>
            (m, "InputTextCallbackData", " Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.\n The callback function should return 0 by default.\n Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)\n - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns True on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)\n - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration\n - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB\n - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows\n - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\n - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.")
        .def_rw("ctx", &ImGuiInputTextCallbackData::Ctx, "Parent UI context")
        .def_rw("event_flag", &ImGuiInputTextCallbackData::EventFlag, "One ImGuiInputTextFlags_Callback*    // Read-only")
        .def_rw("flags", &ImGuiInputTextCallbackData::Flags, "What user passed to InputText()      // Read-only")
        .def_rw("user_data", &ImGuiInputTextCallbackData::UserData, "What user passed to InputText()      // Read-only")
        .def_rw("event_char", &ImGuiInputTextCallbackData::EventChar, "Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;")
        .def_rw("event_key", &ImGuiInputTextCallbackData::EventKey, "Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]")
        .def_ro("buf", &ImGuiInputTextCallbackData::Buf, "Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!")
        .def_rw("buf_text_len", &ImGuiInputTextCallbackData::BufTextLen, "Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()")
        .def_rw("buf_size", &ImGuiInputTextCallbackData::BufSize, "Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1")
        .def_rw("buf_dirty", &ImGuiInputTextCallbackData::BufDirty, "Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]")
        .def_rw("cursor_pos", &ImGuiInputTextCallbackData::CursorPos, "// Read-write   // [Completion,History,Always]")
        .def_rw("selection_start", &ImGuiInputTextCallbackData::SelectionStart, "// Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)")
        .def_rw("selection_end", &ImGuiInputTextCallbackData::SelectionEnd, "// Read-write   // [Completion,History,Always]")
        .def(nb::init<>())
        .def("delete_chars",
            &ImGuiInputTextCallbackData::DeleteChars, nb::arg("pos"), nb::arg("bytes_count"))
        .def("insert_chars",
            [](ImGuiInputTextCallbackData & self, int pos, const char * text, std::optional<std::string> text_end = std::nullopt)
            {
                auto InsertChars_adapt_const_char_pointer_with_default_null = [&self](int pos, const char * text, std::optional<std::string> text_end = std::nullopt)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.InsertChars(pos, text, text_end_adapt_default_null);
                };

                InsertChars_adapt_const_char_pointer_with_default_null(pos, text, text_end);
            },     nb::arg("pos"), nb::arg("text"), nb::arg("text_end") = nb::none())
        .def("select_all",
            &ImGuiInputTextCallbackData::SelectAll, "(private API)")
        .def("clear_selection",
            &ImGuiInputTextCallbackData::ClearSelection, "(private API)")
        .def("has_selection",
            &ImGuiInputTextCallbackData::HasSelection, "(private API)")
        ;


    auto pyClassImGuiSizeCallbackData =
        nb::class_<ImGuiSizeCallbackData>
            (m, "SizeCallbackData", " Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().\n NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.")
        .def("__init__", [](ImGuiSizeCallbackData * self, const std::optional<const ImVec2> & Pos = std::nullopt, const std::optional<const ImVec2> & CurrentSize = std::nullopt, const std::optional<const ImVec2> & DesiredSize = std::nullopt)
        {
            new (self) ImGuiSizeCallbackData();  // placement new
            auto r = self;
            if (Pos.has_value())
                r->Pos = Pos.value();
            else
                r->Pos = ImVec2();
            if (CurrentSize.has_value())
                r->CurrentSize = CurrentSize.value();
            else
                r->CurrentSize = ImVec2();
            if (DesiredSize.has_value())
                r->DesiredSize = DesiredSize.value();
            else
                r->DesiredSize = ImVec2();
        },
        nb::arg("pos") = nb::none(), nb::arg("current_size") = nb::none(), nb::arg("desired_size") = nb::none()
        )
        .def_rw("user_data", &ImGuiSizeCallbackData::UserData, "Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).")
        .def_rw("pos", &ImGuiSizeCallbackData::Pos, "Read-only.   Window position, for reference.")
        .def_rw("current_size", &ImGuiSizeCallbackData::CurrentSize, "Read-only.   Current window size.")
        .def_rw("desired_size", &ImGuiSizeCallbackData::DesiredSize, "Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.")
        ;


    auto pyClassImGuiWindowClass =
        nb::class_<ImGuiWindowClass>
            (m, "WindowClass", " [ALPHA] Rarely used / very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.\n Important: the content of this class is still highly WIP and likely to change and be refactored\n before we stabilize Docking features. Please be mindful if using this.\n Provide hints:\n - To the platform backend via altered viewport flags (enable/disable OS decoration, OS task bar icons, etc.)\n - To the platform backend for OS level parent/child relationships of viewport.\n - To the docking system for various options and filtering.")
        .def_rw("class_id", &ImGuiWindowClass::ClassId, "User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.")
        .def_rw("parent_viewport_id", &ImGuiWindowClass::ParentViewportId, "Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent<>child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.")
        .def_rw("focus_route_parent_window_id", &ImGuiWindowClass::FocusRouteParentWindowId, "ID of parent window for shortcut focus route evaluation, e.g. Shortcut() call from Parent Window will succeed when this window is focused.")
        .def_rw("viewport_flags_override_set", &ImGuiWindowClass::ViewportFlagsOverrideSet, "Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.")
        .def_rw("viewport_flags_override_clear", &ImGuiWindowClass::ViewportFlagsOverrideClear, "Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.")
        .def_rw("tab_item_flags_override_set", &ImGuiWindowClass::TabItemFlagsOverrideSet, "[EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.")
        .def_rw("dock_node_flags_override_set", &ImGuiWindowClass::DockNodeFlagsOverrideSet, "[EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)")
        .def_rw("docking_always_tab_bar", &ImGuiWindowClass::DockingAlwaysTabBar, "Set to True to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)")
        .def_rw("docking_allow_unclassed", &ImGuiWindowClass::DockingAllowUnclassed, "Set to True to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?")
        .def(nb::init<>())
        ;


    auto pyClassImGuiPayload =
        nb::class_<ImGuiPayload>
            (m, "Payload", "Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()")
        .def_rw("data", &ImGuiPayload::Data, "Data (copied and owned by dear imgui)")
        .def_rw("data_size", &ImGuiPayload::DataSize, "Data size")
        .def_rw("source_id", &ImGuiPayload::SourceId, "Source item id")
        .def_rw("source_parent_id", &ImGuiPayload::SourceParentId, "Source parent id (if available)")
        .def_rw("data_frame_count", &ImGuiPayload::DataFrameCount, "Data timestamp")
        .def_rw("preview", &ImGuiPayload::Preview, "Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)")
        .def_rw("delivery", &ImGuiPayload::Delivery, "Set when AcceptDragDropPayload() was called and mouse button is released over the target item.")
        .def(nb::init<>())
        .def("clear",
            &ImGuiPayload::Clear, "(private API)")
        .def("is_data_type",
            &ImGuiPayload::IsDataType,
            nb::arg("type"),
            "(private API)")
        .def("is_preview",
            &ImGuiPayload::IsPreview, "(private API)")
        .def("is_delivery",
            &ImGuiPayload::IsDelivery, "(private API)")
        ;


    auto pyClassImGuiOnceUponAFrame =
        nb::class_<ImGuiOnceUponAFrame>
            (m, "OnceUponAFrame", " Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.\n Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text(\"This will be called only once per frame\");")
        .def(nb::init<>())
        .def_rw("ref_frame", &ImGuiOnceUponAFrame::RefFrame, "")
        .def("__bool__",
            &ImGuiOnceUponAFrame::operator bool)
        ;


    auto pyClassImGuiTextFilter =
        nb::class_<ImGuiTextFilter>
            (m, "TextFilter", "Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"");

    { // inner classes & enums of TextFilter
        auto pyClassImGuiTextFilter_ClassImGuiTextRange =
            nb::class_<ImGuiTextFilter::ImGuiTextRange>
                (pyClassImGuiTextFilter, "TextRange", "[Internal]")
            .def_ro("b", &ImGuiTextFilter::ImGuiTextRange::b, "")
            .def_ro("e", &ImGuiTextFilter::ImGuiTextRange::e, "")
            .def(nb::init<>())
            .def(nb::init<const char *, const char *>(),
                nb::arg("_b"), nb::arg("_e"))
            .def("empty",
                &ImGuiTextFilter::ImGuiTextRange::empty, "(private API)")
            ;
    } // end of inner classes & enums of TextFilter

    pyClassImGuiTextFilter
        .def(nb::init<const char *>(),
            nb::arg("default_filter") = "")
        .def("draw",
            &ImGuiTextFilter::Draw,
            nb::arg("label") = "Filter (inc,-exc)", nb::arg("width") = 0.0f,
            "Helper calling InputText+Build")
        .def("pass_filter",
            [](const ImGuiTextFilter & self, const char * text, std::optional<std::string> text_end = std::nullopt) -> bool
            {
                auto PassFilter_adapt_const_char_pointer_with_default_null = [&self](const char * text, std::optional<std::string> text_end = std::nullopt) -> bool
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    auto lambda_result = self.PassFilter(text, text_end_adapt_default_null);
                    return lambda_result;
                };

                return PassFilter_adapt_const_char_pointer_with_default_null(text, text_end);
            },     nb::arg("text"), nb::arg("text_end") = nb::none())
        .def("build",
            &ImGuiTextFilter::Build)
        .def("clear",
            &ImGuiTextFilter::Clear, "(private API)")
        .def("is_active",
            &ImGuiTextFilter::IsActive, "(private API)")
        .def_rw("count_grep", &ImGuiTextFilter::CountGrep, "")
        ;


    auto pyClassImGuiTextBuffer =
        nb::class_<ImGuiTextBuffer>
            (m, "TextBuffer", " Helper: Growable text buffer for logging/accumulating text\n (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')")
        .def_rw("buf", &ImGuiTextBuffer::Buf, "")
        .def(nb::init<>())
        .def("__getitem__",
            &ImGuiTextBuffer::operator[],
            nb::arg("i"),
            "(private API)")
        .def("begin",
            &ImGuiTextBuffer::begin,
            "(private API)",
            nb::rv_policy::reference)
        .def("end",
            &ImGuiTextBuffer::end,
            "(private API)\n\n Buf is zero-terminated, so end() will point on the zero-terminator",
            nb::rv_policy::reference)
        .def("size",
            &ImGuiTextBuffer::size, "(private API)")
        .def("empty",
            &ImGuiTextBuffer::empty, "(private API)")
        .def("clear",
            &ImGuiTextBuffer::clear, "(private API)")
        .def("reserve",
            &ImGuiTextBuffer::reserve,
            nb::arg("capacity"),
            "(private API)")
        .def("c_str",
            &ImGuiTextBuffer::c_str,
            "(private API)",
            nb::rv_policy::reference)
        .def("append",
            [](ImGuiTextBuffer & self, const char * str, std::optional<std::string> str_end = std::nullopt)
            {
                auto append_adapt_const_char_pointer_with_default_null = [&self](const char * str, std::optional<std::string> str_end = std::nullopt)
                {
                    const char * str_end_adapt_default_null = nullptr;
                    if (str_end.has_value())
                        str_end_adapt_default_null = str_end.value().c_str();

                    self.append(str, str_end_adapt_default_null);
                };

                append_adapt_const_char_pointer_with_default_null(str, str_end);
            },     nb::arg("str"), nb::arg("str_end") = nb::none())
        .def("appendf",
            [](ImGuiTextBuffer & self, const char * fmt)
            {
                auto appendf_adapt_variadic_format = [&self](const char * fmt)
                {
                    self.appendf("%s", fmt);
                };

                appendf_adapt_variadic_format(fmt);
            },     nb::arg("fmt"))
        ;


    auto pyClassImGuiStoragePair =
        nb::class_<ImGuiStoragePair>
            (m, "StoragePair", "[Internal] Key+Value for ImGuiStorage")
        .def_rw("key", &ImGuiStoragePair::key, "")
        .def(nb::init<ImGuiID, int>(),
            nb::arg("_key"), nb::arg("_val"))
        .def(nb::init<ImGuiID, float>(),
            nb::arg("_key"), nb::arg("_val"))
        .def(nb::init<ImGuiID, void *>(),
            nb::arg("_key"), nb::arg("_val"))
        ;


    auto pyClassImGuiStorage =
        nb::class_<ImGuiStorage>
            (m, "Storage", " Helper: Key->Value storage\n Typically you don't have to worry about this since a storage is held within each Window.\n We use it to e.g. store collapse state for a tree (Int 0/1)\n This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)\n You can use it as custom user storage for temporary values. Declare your own storage if, for example:\n - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).\n - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)\n Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.")
        .def(nb::init<>()) // implicit default constructor
        .def("clear",
            &ImGuiStorage::Clear, " - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)\n - Set***() functions find pair, insertion on demand if missing.\n - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.\n(private API)")
        .def("get_int",
            &ImGuiStorage::GetInt, nb::arg("key"), nb::arg("default_val") = 0)
        .def("set_int",
            &ImGuiStorage::SetInt, nb::arg("key"), nb::arg("val"))
        .def("get_bool",
            &ImGuiStorage::GetBool, nb::arg("key"), nb::arg("default_val") = false)
        .def("set_bool",
            &ImGuiStorage::SetBool, nb::arg("key"), nb::arg("val"))
        .def("get_float",
            &ImGuiStorage::GetFloat, nb::arg("key"), nb::arg("default_val") = 0.0f)
        .def("set_float",
            &ImGuiStorage::SetFloat, nb::arg("key"), nb::arg("val"))
        .def("get_void_ptr",
            &ImGuiStorage::GetVoidPtr,
            nb::arg("key"),
            "default_val is None",
            nb::rv_policy::reference)
        .def("set_void_ptr",
            &ImGuiStorage::SetVoidPtr, nb::arg("key"), nb::arg("val"))
        .def("get_int_ref",
            &ImGuiStorage::GetIntRef,
            nb::arg("key"), nb::arg("default_val") = 0,
            nb::rv_policy::reference)
        .def("get_bool_ref",
            &ImGuiStorage::GetBoolRef,
            nb::arg("key"), nb::arg("default_val") = false,
            nb::rv_policy::reference)
        .def("get_float_ref",
            &ImGuiStorage::GetFloatRef,
            nb::arg("key"), nb::arg("default_val") = 0.0f,
            nb::rv_policy::reference)
        .def("build_sort_by_key",
            &ImGuiStorage::BuildSortByKey, "Advanced: for quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.")
        .def("set_all_int",
            &ImGuiStorage::SetAllInt,
            nb::arg("val"),
            "Obsolete: use on your own storage if you know only integer are being stored (open/close all tree nodes)")
        ;


    auto pyClassImGuiListClipper =
        nb::class_<ImGuiListClipper>
            (m, "ListClipper", " Helper: Manually clip large list of items.\n If you have lots evenly spaced items and you have random access to the list, you can perform coarse\n clipping based on visibility to only submit items that are in view.\n The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.\n (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally\n  fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily\n  scale using lists with tens of thousands of items without a problem)\n Usage:\n   ImGuiListClipper clipper;\n   clipper.Begin(1000);         // We have 1000 elements, evenly spaced.\n   while (clipper.Step())\n       for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n           ImGui::Text(\"line number %d\", i);\n Generally what happens is:\n - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.\n - User code submit that one element.\n - Clipper can measure the height of the first element\n - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.\n - User code submit visible elements.\n - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.")
        .def_rw("ctx", &ImGuiListClipper::Ctx, "Parent UI context")
        .def_rw("display_start", &ImGuiListClipper::DisplayStart, "First item to display, updated by each call to Step()")
        .def_rw("display_end", &ImGuiListClipper::DisplayEnd, "End of items to display (exclusive)")
        .def_rw("items_count", &ImGuiListClipper::ItemsCount, "[Internal] Number of items")
        .def_rw("items_height", &ImGuiListClipper::ItemsHeight, "[Internal] Height of item after a first step and item submission can calculate it")
        .def_rw("start_pos_y", &ImGuiListClipper::StartPosY, "[Internal] Cursor position at the time of Begin() or after table frozen rows are all processed")
        .def_rw("start_seek_offset_y", &ImGuiListClipper::StartSeekOffsetY, "[Internal] Account for frozen rows in a table and initial loss of precision in very large windows.")
        .def_rw("temp_data", &ImGuiListClipper::TempData, "[Internal] Internal data")
        .def(nb::init<>(),
            " items_count: Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step, and you can call SeekCursorForItem() manually if you need)\n items_height: Use -1.0 to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().")
        .def("begin",
            &ImGuiListClipper::Begin, nb::arg("items_count"), nb::arg("items_height") = -1.0f)
        .def("end",
            &ImGuiListClipper::End, "Automatically called on the last call of Step() that returns False.")
        .def("step",
            &ImGuiListClipper::Step, "Call until it returns False. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.")
        .def("include_item_by_index",
            &ImGuiListClipper::IncludeItemByIndex,
            nb::arg("item_index"),
            " Call IncludeItemByIndex() or IncludeItemsByIndex() *BEFORE* first call to Step() if you need a range of items to not be clipped, regardless of their visibility.\n (Due to alignment / padding of certain items it is possible that an extra item may be included on either end of the display range).\n(private API)")
        .def("include_items_by_index",
            &ImGuiListClipper::IncludeItemsByIndex,
            nb::arg("item_begin"), nb::arg("item_end"),
            "item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.")
        .def("seek_cursor_for_item",
            &ImGuiListClipper::SeekCursorForItem,
            nb::arg("item_index"),
            " Seek cursor toward given item. This is automatically called while stepping.\n - The only reason to call this is: you can use ImGuiListClipper::Begin(INT_MAX) if you don't know item count ahead of time.\n - In this case, after all steps are done, you'll want to call SeekCursorForItem(item_count).")
        ;


    auto pyClassImColor =
        nb::class_<ImColor>
            (m, "ImColor", " Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)\n Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.\n **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.\n **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.")
        .def_rw("value", &ImColor::Value, "")
        .def(nb::init<>())
        .def(nb::init<float, float, float, float>(),
            nb::arg("r"), nb::arg("g"), nb::arg("b"), nb::arg("a") = 1.0f)
        .def(nb::init<const ImVec4 &>(),
            nb::arg("col"))
        .def(nb::init<int, int, int, int>(),
            nb::arg("r"), nb::arg("g"), nb::arg("b"), nb::arg("a") = 255)
        .def(nb::init<ImU32>(),
            nb::arg("rgba"))
        .def("set_hsv",
            &ImColor::SetHSV,
            nb::arg("h"), nb::arg("s"), nb::arg("v"), nb::arg("a") = 1.0f,
            "(private API)")
        .def_static("hsv",
            &ImColor::HSV,
            nb::arg("h"), nb::arg("s"), nb::arg("v"), nb::arg("a") = 1.0f,
            "(private API)")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("to_dict",
            &ImColor::to_dict, "(private API)")
        .def_static("from_dict",
            &ImColor::from_dict,
            nb::arg("d"),
            "(private API)")
        // #endif
        //
        .def("__copy__",  [](const ImColor &self) {
            return ImColor(self);
        })    ;


    auto pyEnumMultiSelectFlags_ =
        nb::enum_<ImGuiMultiSelectFlags_>(m, "MultiSelectFlags_", nb::is_arithmetic(), "Flags for BeginMultiSelect()")
            .value("none", ImGuiMultiSelectFlags_None, "")
            .value("single_select", ImGuiMultiSelectFlags_SingleSelect, "Disable selecting more than one item. This is available to allow single-selection code to share same code/logic if desired. It essentially disables the main purpose of BeginMultiSelect() tho!")
            .value("no_select_all", ImGuiMultiSelectFlags_NoSelectAll, "Disable CTRL+A shortcut to select all.")
            .value("no_range_select", ImGuiMultiSelectFlags_NoRangeSelect, "Disable Shift+selection mouse/keyboard support (useful for unordered 2D selection). With BoxSelect is also ensure contiguous SetRange requests are not combined into one. This allows not handling interpolation in SetRange requests.")
            .value("no_auto_select", ImGuiMultiSelectFlags_NoAutoSelect, "Disable selecting items when navigating (useful for e.g. supporting range-select in a list of checkboxes).")
            .value("no_auto_clear", ImGuiMultiSelectFlags_NoAutoClear, "Disable clearing selection when navigating or selecting another one (generally used with ImGuiMultiSelectFlags_NoAutoSelect. useful for e.g. supporting range-select in a list of checkboxes).")
            .value("no_auto_clear_on_reselect", ImGuiMultiSelectFlags_NoAutoClearOnReselect, "Disable clearing selection when clicking/selecting an already selected item.")
            .value("box_select1d", ImGuiMultiSelectFlags_BoxSelect1d, "Enable box-selection with same width and same x pos items (e.g. full row Selectable()). Box-selection works better with little bit of spacing between items hit-box in order to be able to aim at empty space.")
            .value("box_select2d", ImGuiMultiSelectFlags_BoxSelect2d, "Enable box-selection with varying width or varying x pos items support (e.g. different width labels, or 2D layout/grid). This is slower: alters clipping logic so that e.g. horizontal movements will update selection of normally clipped items.")
            .value("box_select_no_scroll", ImGuiMultiSelectFlags_BoxSelectNoScroll, "Disable scrolling when box-selecting near edges of scope.")
            .value("clear_on_escape", ImGuiMultiSelectFlags_ClearOnEscape, "Clear selection when pressing Escape while scope is focused.")
            .value("clear_on_click_void", ImGuiMultiSelectFlags_ClearOnClickVoid, "Clear selection when clicking on empty location within scope.")
            .value("scope_window", ImGuiMultiSelectFlags_ScopeWindow, "Scope for _BoxSelect and _ClearOnClickVoid is whole window (Default). Use if BeginMultiSelect() covers a whole window or used a single time in same window.")
            .value("scope_rect", ImGuiMultiSelectFlags_ScopeRect, "Scope for _BoxSelect and _ClearOnClickVoid is rectangle encompassing BeginMultiSelect()/EndMultiSelect(). Use if BeginMultiSelect() is called multiple times in same window.")
            .value("select_on_click", ImGuiMultiSelectFlags_SelectOnClick, "Apply selection on mouse down when clicking on unselected item. (Default)")
            .value("select_on_click_release", ImGuiMultiSelectFlags_SelectOnClickRelease, "Apply selection on mouse release when clicking an unselected item. Allow dragging an unselected item without altering selection.")
            .value("nav_wrap_x", ImGuiMultiSelectFlags_NavWrapX, "[Temporary] Enable navigation wrapping on X axis. Provided as a convenience because we don't have a design for the general Nav API for this yet. When the more general feature be public we may obsolete this flag in favor of new one.");


    auto pyClassImGuiMultiSelectIO =
        nb::class_<ImGuiMultiSelectIO>
            (m, "MultiSelectIO", " Main IO structure returned by BeginMultiSelect()/EndMultiSelect().\n This mainly contains a list of selection requests.\n - Use 'Demo->Tools->Debug Log->Selection' to see requests as they happen.\n - Some fields are only useful if your list is dynamic and allows deletion (getting post-deletion focus/state right is shown in the demo)\n - Below: who reads/writes each fields? 'r'=read, 'w'=write, 'ms'=multi-select code, 'app'=application/user code.")
        .def("__init__", [](ImGuiMultiSelectIO * self, const std::optional<const ImVector<ImGuiSelectionRequest>> & Requests = std::nullopt, const std::optional<const ImGuiSelectionUserData> & RangeSrcItem = std::nullopt, const std::optional<const ImGuiSelectionUserData> & NavIdItem = std::nullopt, bool NavIdSelected = bool(), bool RangeSrcReset = bool(), int ItemsCount = int())
        {
            new (self) ImGuiMultiSelectIO();  // placement new
            auto r = self;
            if (Requests.has_value())
                r->Requests = Requests.value();
            else
                r->Requests = ImVector<ImGuiSelectionRequest>();
            if (RangeSrcItem.has_value())
                r->RangeSrcItem = RangeSrcItem.value();
            else
                r->RangeSrcItem = ImGuiSelectionUserData();
            if (NavIdItem.has_value())
                r->NavIdItem = NavIdItem.value();
            else
                r->NavIdItem = ImGuiSelectionUserData();
            r->NavIdSelected = NavIdSelected;
            r->RangeSrcReset = RangeSrcReset;
            r->ItemsCount = ItemsCount;
        },
        nb::arg("requests") = nb::none(), nb::arg("range_src_item") = nb::none(), nb::arg("nav_id_item") = nb::none(), nb::arg("nav_id_selected") = bool(), nb::arg("range_src_reset") = bool(), nb::arg("items_count") = int()
        )
        .def_rw("requests", &ImGuiMultiSelectIO::Requests, "ms:w, app:r     /  ms:w  app:r   // Requests to apply to your selection data.")
        .def_rw("range_src_item", &ImGuiMultiSelectIO::RangeSrcItem, "ms:w  app:r     /                // (If using clipper) Begin: Source item (often the first selected item) must never be clipped: use clipper.IncludeItemByIndex() to ensure it is submitted.")
        .def_rw("nav_id_item", &ImGuiMultiSelectIO::NavIdItem, "ms:w, app:r     /                // (If using deletion) Last known SetNextItemSelectionUserData() value for NavId (if part of submitted items).")
        .def_rw("nav_id_selected", &ImGuiMultiSelectIO::NavIdSelected, "ms:w, app:r     /        app:r   // (If using deletion) Last known selection state for NavId (if part of submitted items).")
        .def_rw("range_src_reset", &ImGuiMultiSelectIO::RangeSrcReset, "app:w     /  ms:r          // (If using deletion) Set before EndMultiSelect() to reset ResetSrcItem (e.g. if deleted selection).")
        .def_rw("items_count", &ImGuiMultiSelectIO::ItemsCount, "ms:w, app:r     /        app:r   // 'int items_count' parameter to BeginMultiSelect() is copied here for convenience, allowing simpler calls to your ApplyRequests handler. Not used internally.")
        ;


    auto pyEnumSelectionRequestType =
        nb::enum_<ImGuiSelectionRequestType>(m, "SelectionRequestType", nb::is_arithmetic(), "Selection request type")
            .value("none", ImGuiSelectionRequestType_None, "")
            .value("set_all", ImGuiSelectionRequestType_SetAll, "Request app to clear selection (if Selected==False) or select all items (if Selected==True). We cannot set RangeFirstItem/RangeLastItem as its contents is entirely up to user (not necessarily an index)")
            .value("set_range", ImGuiSelectionRequestType_SetRange, "Request app to select/unselect [RangeFirstItem..RangeLastItem] items (inclusive) based on value of Selected. Only EndMultiSelect() request this, app code can read after BeginMultiSelect() and it will always be False.");


    auto pyClassImGuiSelectionRequest =
        nb::class_<ImGuiSelectionRequest>
            (m, "SelectionRequest", "Selection request item")
        .def("__init__", [](ImGuiSelectionRequest * self, ImGuiSelectionRequestType Type = ImGuiSelectionRequestType(), bool Selected = bool(), ImS8 RangeDirection = ImS8(), const std::optional<const ImGuiSelectionUserData> & RangeFirstItem = std::nullopt, const std::optional<const ImGuiSelectionUserData> & RangeLastItem = std::nullopt)
        {
            new (self) ImGuiSelectionRequest();  // placement new
            auto r = self;
            r->Type = Type;
            r->Selected = Selected;
            r->RangeDirection = RangeDirection;
            if (RangeFirstItem.has_value())
                r->RangeFirstItem = RangeFirstItem.value();
            else
                r->RangeFirstItem = ImGuiSelectionUserData();
            if (RangeLastItem.has_value())
                r->RangeLastItem = RangeLastItem.value();
            else
                r->RangeLastItem = ImGuiSelectionUserData();
        },
        nb::arg("type") = ImGuiSelectionRequestType(), nb::arg("selected") = bool(), nb::arg("range_direction") = ImS8(), nb::arg("range_first_item") = nb::none(), nb::arg("range_last_item") = nb::none()
        )
        .def_rw("type", &ImGuiSelectionRequest::Type, "ms:w, app:r     /  ms:w, app:r   // Request type. You'll most often receive 1 Clear + 1 SetRange with a single-item range.")
        .def_rw("selected", &ImGuiSelectionRequest::Selected, "ms:w, app:r     /  ms:w, app:r   // Parameter for SetAll/SetRange requests (True = select, False = unselect)")
        .def_rw("range_direction", &ImGuiSelectionRequest::RangeDirection, "/  ms:w  app:r   // Parameter for SetRange request: +1 when RangeFirstItem comes before RangeLastItem, -1 otherwise. Useful if you want to preserve selection order on a backward Shift+Click.")
        .def_rw("range_first_item", &ImGuiSelectionRequest::RangeFirstItem, "/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from top to bottom).")
        .def_rw("range_last_item", &ImGuiSelectionRequest::RangeLastItem, "/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from bottom to top). Inclusive!")
        ;


    auto pyClassImGuiSelectionBasicStorage =
        nb::class_<ImGuiSelectionBasicStorage>
            (m, "SelectionBasicStorage", " Optional helper to store multi-selection state + apply multi-selection requests.\n - Used by our demos and provided as a convenience to easily implement basic multi-selection.\n - Iterate selection with 'None* it = None; ImGuiID id; while (selection.GetNextSelectedItem(&it, &id)) { ... }'\n   Or you can check 'if (Contains(id)) { ... }' for each possible object if their number is not too high to iterate.\n - USING THIS IS NOT MANDATORY. This is only a helper and not a required API.\n To store a multi-selection, in your application you could:\n - Use this helper as a convenience. We use our simple key->value ImGuiStorage as a std::set<ImGuiID> replacement.\n - Use your own external storage: e.g. std::set<MyObjectId>, std::vector<MyObjectId>, interval trees, intrusively stored selection etc.\n In ImGuiSelectionBasicStorage we:\n - always use indices in the multi-selection API (passed to SetNextItemSelectionUserData(), retrieved in ImGuiMultiSelectIO)\n - use the AdapterIndexToStorageId() indirection layer to abstract how persistent selection data is derived from an index.\n - use decently optimized logic to allow queries and insertion of very large selection sets.\n - do not preserve selection order.\n Many combinations are possible depending on how you prefer to store your items and how you prefer to store your selection.\n Large applications are likely to eventually want to get rid of this indirection layer and do their own thing.\n See https://github.com/ocornut/imgui/wiki/Multi-Select for details and pseudo-code using this helper.")
        .def_rw("size", &ImGuiSelectionBasicStorage::Size, "// Number of selected items, maintained by this helper.")
        .def_rw("preserve_order", &ImGuiSelectionBasicStorage::PreserveOrder, "= False  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)")
        .def_rw("user_data", &ImGuiSelectionBasicStorage::UserData, "= None   // User data for use by adapter function        // e.g. selection.UserData = (None*)my_items;")
        .def_rw("_selection_order", &ImGuiSelectionBasicStorage::_SelectionOrder, "[Internal] Increasing counter to store selection order")
        .def_rw("_storage", &ImGuiSelectionBasicStorage::_Storage, "[Internal] Selection set. Think of this as similar to e.g. std::set<ImGuiID>. Prefer not accessing directly: iterate with GetNextSelectedItem().")
        .def(nb::init<>())
        .def("apply_requests",
            &ImGuiSelectionBasicStorage::ApplyRequests,
            nb::arg("ms_io"),
            "Apply selection requests coming from BeginMultiSelect() and EndMultiSelect() functions. It uses 'items_count' passed to BeginMultiSelect()")
        .def("contains",
            [](const ImGuiSelectionBasicStorage & self, ImGuiID id) -> bool
            {
                auto Contains_adapt_force_lambda = [&self](ImGuiID id) -> bool
                {
                    auto lambda_result = self.Contains(id);
                    return lambda_result;
                };

                return Contains_adapt_force_lambda(id);
            },
            nb::arg("id_"),
            "Query if an item id is in selection.")
        .def("clear",
            &ImGuiSelectionBasicStorage::Clear, "Clear selection")
        .def("swap",
            &ImGuiSelectionBasicStorage::Swap,
            nb::arg("r"),
            "Swap two selections")
        .def("set_item_selected",
            &ImGuiSelectionBasicStorage::SetItemSelected,
            nb::arg("id_"), nb::arg("selected"),
            "Add/remove an item from selection (generally done by ApplyRequests() function)")
        .def("get_storage_id_from_index",
            &ImGuiSelectionBasicStorage::GetStorageIdFromIndex,
            nb::arg("idx"),
            "(private API)\n\n Convert index to item id based on provided adapter.")
        ;


    auto pyClassImGuiSelectionExternalStorage =
        nb::class_<ImGuiSelectionExternalStorage>
            (m, "SelectionExternalStorage", " Optional helper to apply multi-selection requests to existing randomly accessible storage.\n Convenient if you want to quickly wire multi-select API on e.g. an array of bool or items storing their own selection state.")
        .def_rw("user_data", &ImGuiSelectionExternalStorage::UserData, "User data for use by adapter function                                // e.g. selection.UserData = (None*)my_items;")
        .def(nb::init<>())
        .def("apply_requests",
            &ImGuiSelectionExternalStorage::ApplyRequests,
            nb::arg("ms_io"),
            "Apply selection requests by using AdapterSetItemSelected() calls")
        ;


    auto pyClassImDrawCmd =
        nb::class_<ImDrawCmd>
            (m, "ImDrawCmd", " Typically, 1 command = 1 GPU draw call (unless command is a callback)\n - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,\n   this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.\n   Backends made for <1.71. will typically ignore the VtxOffset fields.\n - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).")
        .def_rw("clip_rect", &ImDrawCmd::ClipRect, "4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in \"viewport\" coordinates")
        .def_rw("texture_id", &ImDrawCmd::TextureId, "4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.")
        .def_rw("vtx_offset", &ImDrawCmd::VtxOffset, "4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.")
        .def_rw("idx_offset", &ImDrawCmd::IdxOffset, "4    // Start offset in index buffer.")
        .def_rw("elem_count", &ImDrawCmd::ElemCount, "4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].")
        .def_rw("user_callback_data", &ImDrawCmd::UserCallbackData, "4-8  // Callback user data (when UserCallback != None). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size > 0, this is pointing to a buffer where data is stored.")
        .def_rw("user_callback_data_size", &ImDrawCmd::UserCallbackDataSize, "4 // Size of callback user data when using storage, otherwise 0.")
        .def_rw("user_callback_data_offset", &ImDrawCmd::UserCallbackDataOffset, "4 // [Internal] Offset of callback user data when using storage, otherwise -1.")
        .def(nb::init<>(),
            "Also ensure our padding fields are zeroed")
        .def("get_tex_id",
            &ImDrawCmd::GetTexID, " Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)\n(private API)")
        ;
    // #ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
    //

}
