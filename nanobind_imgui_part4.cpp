// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2024 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>


namespace nb = nanobind;


#include "imgui.h"
#include "imgui_internal.h"

using uint = unsigned int;
using uchar = unsigned char;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void nanobind_imgui_part4(nb::module_& m)
{
    auto pyClassImDrawVert =
        nb::class_<ImDrawVert>
            (m, "ImDrawVert", "")
        .def("__init__", [](ImDrawVert * self, const std::optional<const ImVec2> & pos = std::nullopt, const std::optional<const ImVec2> & uv = std::nullopt, ImU32 col = ImU32())
        {
            new (self) ImDrawVert();  // placement new
            auto r = self;
            if (pos.has_value())
                r->pos = pos.value();
            else
                r->pos = ImVec2();
            if (uv.has_value())
                r->uv = uv.value();
            else
                r->uv = ImVec2();
            r->col = col;
        },
        nb::arg("pos") = nb::none(), nb::arg("uv") = nb::none(), nb::arg("col") = ImU32()
        )
        .def_rw("pos", &ImDrawVert::pos, "")
        .def_rw("uv", &ImDrawVert::uv, "")
        .def_rw("col", &ImDrawVert::col, "")
        ;
    // #else
    //
    // #endif
    //


    auto pyClassImDrawCmdHeader =
        nb::class_<ImDrawCmdHeader>
            (m, "ImDrawCmdHeader", "[Internal] For use by ImDrawList")
        .def("__init__", [](ImDrawCmdHeader * self, const std::optional<const ImVec4> & ClipRect = std::nullopt, const std::optional<const ImTextureID> & TextureId = std::nullopt)
        {
            new (self) ImDrawCmdHeader();  // placement new
            auto r = self;
            if (ClipRect.has_value())
                r->ClipRect = ClipRect.value();
            else
                r->ClipRect = ImVec4();
            if (TextureId.has_value())
                r->TextureId = TextureId.value();
            else
                r->TextureId = ImTextureID();
        },
        nb::arg("clip_rect") = nb::none(), nb::arg("texture_id") = nb::none()
        )
        .def_rw("clip_rect", &ImDrawCmdHeader::ClipRect, "")
        .def_rw("texture_id", &ImDrawCmdHeader::TextureId, "")
        .def_rw("vtx_offset", &ImDrawCmdHeader::VtxOffset, "")
        ;


    auto pyClassImDrawChannel =
        nb::class_<ImDrawChannel>
            (m, "ImDrawChannel", "[Internal] For use by ImDrawListSplitter")
        .def("__init__", [](ImDrawChannel * self, const std::optional<const ImVector<ImDrawCmd>> & _CmdBuffer = std::nullopt, const std::optional<const ImVector<ImDrawIdx>> & _IdxBuffer = std::nullopt)
        {
            new (self) ImDrawChannel();  // placement new
            auto r = self;
            if (_CmdBuffer.has_value())
                r->_CmdBuffer = _CmdBuffer.value();
            else
                r->_CmdBuffer = ImVector<ImDrawCmd>();
            if (_IdxBuffer.has_value())
                r->_IdxBuffer = _IdxBuffer.value();
            else
                r->_IdxBuffer = ImVector<ImDrawIdx>();
        },
        nb::arg("_cmd_buffer") = nb::none(), nb::arg("_idx_buffer") = nb::none()
        )
        .def_rw("_cmd_buffer", &ImDrawChannel::_CmdBuffer, "")
        .def_rw("_idx_buffer", &ImDrawChannel::_IdxBuffer, "")
        ;


    auto pyClassImDrawListSplitter =
        nb::class_<ImDrawListSplitter>
            (m, "ImDrawListSplitter", " Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.\n This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.")
        .def_rw("_current", &ImDrawListSplitter::_Current, "Current channel number (0)")
        .def_rw("_count", &ImDrawListSplitter::_Count, "Number of active channels (1+)")
        .def_rw("_channels", &ImDrawListSplitter::_Channels, "Draw channels (not resized down so _Count might be < Channels.Size)")
        .def(nb::init<>())
        .def("clear",
            &ImDrawListSplitter::Clear, "(private API)\n\n Do not clear Channels[] so our allocations are reused next frame")
        .def("clear_free_memory",
            &ImDrawListSplitter::ClearFreeMemory)
        .def("split",
            &ImDrawListSplitter::Split, nb::arg("draw_list"), nb::arg("count"))
        .def("merge",
            &ImDrawListSplitter::Merge, nb::arg("draw_list"))
        .def("set_current_channel",
            &ImDrawListSplitter::SetCurrentChannel, nb::arg("draw_list"), nb::arg("channel_idx"))
        ;


    auto pyEnumImDrawFlags_ =
        nb::enum_<ImDrawFlags_>(m, "ImDrawFlags_", nb::is_arithmetic(), " Flags for ImDrawList functions\n (Legacy: bit 0 must always correspond to ImDrawFlags_Closed to be backward compatible with old API using a bool. Bits 1..3 must be unused)")
            .value("none", ImDrawFlags_None, "")
            .value("closed", ImDrawFlags_Closed, "PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)")
            .value("round_corners_top_left", ImDrawFlags_RoundCornersTopLeft, "AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0, we default to all corners). Was 0x01.")
            .value("round_corners_top_right", ImDrawFlags_RoundCornersTopRight, "AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0, we default to all corners). Was 0x02.")
            .value("round_corners_bottom_left", ImDrawFlags_RoundCornersBottomLeft, "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0, we default to all corners). Was 0x04.")
            .value("round_corners_bottom_right", ImDrawFlags_RoundCornersBottomRight, "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0, we default to all corners). Wax 0x08.")
            .value("round_corners_none", ImDrawFlags_RoundCornersNone, "AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0). This is NOT zero, NOT an implicit flag!")
            .value("round_corners_top", ImDrawFlags_RoundCornersTop, "")
            .value("round_corners_bottom", ImDrawFlags_RoundCornersBottom, "")
            .value("round_corners_left", ImDrawFlags_RoundCornersLeft, "")
            .value("round_corners_right", ImDrawFlags_RoundCornersRight, "")
            .value("round_corners_all", ImDrawFlags_RoundCornersAll, "")
            .value("round_corners_default_", ImDrawFlags_RoundCornersDefault_, "Default to ALL corners if none of the _RoundCornersXX flags are specified.")
            .value("round_corners_mask_", ImDrawFlags_RoundCornersMask_, "");


    auto pyEnumImDrawListFlags_ =
        nb::enum_<ImDrawListFlags_>(m, "ImDrawListFlags_", nb::is_arithmetic(), " Flags for ImDrawList instance. Those are set automatically by ImGui:: functions from ImGuiIO settings, and generally not manipulated directly.\n It is however possible to temporarily alter flags between calls to ImDrawList:: functions.")
            .value("none", ImDrawListFlags_None, "")
            .value("anti_aliased_lines", ImDrawListFlags_AntiAliasedLines, "Enable anti-aliased lines/borders (*2 the number of triangles for 1.0 wide line or lines thin enough to be drawn using textures, otherwise *3 the number of triangles)")
            .value("anti_aliased_lines_use_tex", ImDrawListFlags_AntiAliasedLinesUseTex, "Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).")
            .value("anti_aliased_fill", ImDrawListFlags_AntiAliasedFill, "Enable anti-aliased edge around filled shapes (rounded rectangles, circles).")
            .value("allow_vtx_offset", ImDrawListFlags_AllowVtxOffset, "Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.");


    auto pyClassImDrawList =
        nb::class_<ImDrawList>
            (m, "ImDrawList", " Draw command list\n This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,\n all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.\n Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to\n access the current window draw list and draw custom primitives.\n You can interleave normal ImGui:: calls and adding primitives to the current draw list.\n In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).\n You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)\n Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.")
        .def_rw("cmd_buffer", &ImDrawList::CmdBuffer, "Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.")
        .def_rw("idx_buffer", &ImDrawList::IdxBuffer, "Index buffer. Each command consume ImDrawCmd::ElemCount of those")
        .def_rw("vtx_buffer", &ImDrawList::VtxBuffer, "Vertex buffer.")
        .def_rw("flags", &ImDrawList::Flags, "Flags, you may poke into these to adjust anti-aliasing settings per-primitive.")
        .def_rw("_vtx_current_idx", &ImDrawList::_VtxCurrentIdx, "[Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.")
        .def_rw("_data", &ImDrawList::_Data, "Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)")
        .def_rw("_vtx_write_ptr", &ImDrawList::_VtxWritePtr, "[Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)")
        .def_rw("_idx_write_ptr", &ImDrawList::_IdxWritePtr, "[Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)")
        .def_rw("_path", &ImDrawList::_Path, "[Internal] current path building")
        .def_rw("_cmd_header", &ImDrawList::_CmdHeader, "[Internal] template of active commands. Fields should match those of CmdBuffer.back().")
        .def_rw("_splitter", &ImDrawList::_Splitter, "[Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)")
        .def_rw("_clip_rect_stack", &ImDrawList::_ClipRectStack, "[Internal]")
        .def_rw("_texture_id_stack", &ImDrawList::_TextureIdStack, "[Internal]")
        .def_rw("_fringe_scale", &ImDrawList::_FringeScale, "[Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content")
        .def_ro("_owner_name", &ImDrawList::_OwnerName, "Pointer to owner window's name for debugging")
        .def(nb::init<ImDrawListSharedData *>(),
            nb::arg("shared_data"),
            "If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)")
        .def("push_clip_rect",
            &ImDrawList::PushClipRect,
            nb::arg("clip_rect_min"), nb::arg("clip_rect_max"), nb::arg("intersect_with_current_clip_rect") = false,
            "Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)")
        .def("push_clip_rect_full_screen",
            &ImDrawList::PushClipRectFullScreen)
        .def("pop_clip_rect",
            &ImDrawList::PopClipRect)
        .def("push_texture_id",
            &ImDrawList::PushTextureID, nb::arg("texture_id"))
        .def("pop_texture_id",
            &ImDrawList::PopTextureID)
        .def("get_clip_rect_min",
            &ImDrawList::GetClipRectMin, "(private API)")
        .def("get_clip_rect_max",
            &ImDrawList::GetClipRectMax, "(private API)")
        .def("add_line",
            &ImDrawList::AddLine, nb::arg("p1"), nb::arg("p2"), nb::arg("col"), nb::arg("thickness") = 1.0f)
        .def("add_rect",
            &ImDrawList::AddRect,
            nb::arg("p_min"), nb::arg("p_max"), nb::arg("col"), nb::arg("rounding") = 0.0f, nb::arg("flags") = 0, nb::arg("thickness") = 1.0f,
            "a: upper-left, b: lower-right (== upper-left + size)")
        .def("add_rect_filled",
            &ImDrawList::AddRectFilled,
            nb::arg("p_min"), nb::arg("p_max"), nb::arg("col"), nb::arg("rounding") = 0.0f, nb::arg("flags") = 0,
            "a: upper-left, b: lower-right (== upper-left + size)")
        .def("add_rect_filled_multi_color",
            &ImDrawList::AddRectFilledMultiColor, nb::arg("p_min"), nb::arg("p_max"), nb::arg("col_upr_left"), nb::arg("col_upr_right"), nb::arg("col_bot_right"), nb::arg("col_bot_left"))
        .def("add_quad",
            &ImDrawList::AddQuad, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("col"), nb::arg("thickness") = 1.0f)
        .def("add_quad_filled",
            &ImDrawList::AddQuadFilled, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("col"))
        .def("add_triangle",
            &ImDrawList::AddTriangle, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("col"), nb::arg("thickness") = 1.0f)
        .def("add_triangle_filled",
            &ImDrawList::AddTriangleFilled, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("col"))
        .def("add_circle",
            &ImDrawList::AddCircle, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments") = 0, nb::arg("thickness") = 1.0f)
        .def("add_circle_filled",
            &ImDrawList::AddCircleFilled, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments") = 0)
        .def("add_ngon",
            &ImDrawList::AddNgon, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments"), nb::arg("thickness") = 1.0f)
        .def("add_ngon_filled",
            &ImDrawList::AddNgonFilled, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments"))
        .def("add_ellipse",
            &ImDrawList::AddEllipse, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("rot") = 0.0f, nb::arg("num_segments") = 0, nb::arg("thickness") = 1.0f)
        .def("add_ellipse_filled",
            &ImDrawList::AddEllipseFilled, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("rot") = 0.0f, nb::arg("num_segments") = 0)
        .def("add_text",
            [](ImDrawList & self, const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt)
            {
                auto AddText_adapt_const_char_pointer_with_default_null = [&self](const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.AddText(pos, col, text_begin, text_end_adapt_default_null);
                };

                AddText_adapt_const_char_pointer_with_default_null(pos, col, text_begin, text_end);
            },     nb::arg("pos"), nb::arg("col"), nb::arg("text_begin"), nb::arg("text_end") = nb::none())
        .def("add_text",
            [](ImDrawList & self, const ImFont * font, float font_size, const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt, float wrap_width = 0.0f, const ImVec4 * cpu_fine_clip_rect = NULL)
            {
                auto AddText_adapt_const_char_pointer_with_default_null = [&self](const ImFont * font, float font_size, const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt, float wrap_width = 0.0f, const ImVec4 * cpu_fine_clip_rect = NULL)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.AddText(font, font_size, pos, col, text_begin, text_end_adapt_default_null, wrap_width, cpu_fine_clip_rect);
                };

                AddText_adapt_const_char_pointer_with_default_null(font, font_size, pos, col, text_begin, text_end, wrap_width, cpu_fine_clip_rect);
            },     nb::arg("font"), nb::arg("font_size"), nb::arg("pos"), nb::arg("col"), nb::arg("text_begin"), nb::arg("text_end") = nb::none(), nb::arg("wrap_width") = 0.0f, nb::arg("cpu_fine_clip_rect") = nb::none())
        .def("add_bezier_cubic",
            &ImDrawList::AddBezierCubic,
            nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("col"), nb::arg("thickness"), nb::arg("num_segments") = 0,
            "Cubic Bezier (4 control points)")
        .def("add_bezier_quadratic",
            &ImDrawList::AddBezierQuadratic, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("col"), nb::arg("thickness"), nb::arg("num_segments") = 0)
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("add_polyline",
            nb::overload_cast<const std::vector<ImVec2> &, ImU32, ImDrawFlags, float>(&ImDrawList::AddPolyline), nb::arg("points"), nb::arg("col"), nb::arg("flags"), nb::arg("thickness"))
        .def("add_convex_poly_filled",
            nb::overload_cast<const std::vector<ImVec2> &, ImU32>(&ImDrawList::AddConvexPolyFilled), nb::arg("points"), nb::arg("col"))
        .def("add_concave_poly_filled",
            nb::overload_cast<const std::vector<ImVec2> &, ImU32>(&ImDrawList::AddConcavePolyFilled), nb::arg("points"), nb::arg("col"))
        // #endif
        //
        .def("add_image",
            [](ImDrawList & self, ImTextureID user_texture_id, const ImVec2 & p_min, const ImVec2 & p_max, const std::optional<const ImVec2> & uv_min = std::nullopt, const std::optional<const ImVec2> & uv_max = std::nullopt, ImU32 col = IM_COL32_WHITE)
            {
                auto AddImage_adapt_mutable_param_with_default_value = [&self](ImTextureID user_texture_id, const ImVec2 & p_min, const ImVec2 & p_max, const std::optional<const ImVec2> & uv_min = std::nullopt, const std::optional<const ImVec2> & uv_max = std::nullopt, ImU32 col = IM_COL32_WHITE)
                {

                    const ImVec2& uv_min_or_default = [&]() -> const ImVec2 {
                        if (uv_min.has_value())
                            return uv_min.value();
                        else
                            return ImVec2(0, 0);
                    }();

                    const ImVec2& uv_max_or_default = [&]() -> const ImVec2 {
                        if (uv_max.has_value())
                            return uv_max.value();
                        else
                            return ImVec2(1, 1);
                    }();

                    self.AddImage(user_texture_id, p_min, p_max, uv_min_or_default, uv_max_or_default, col);
                };

                AddImage_adapt_mutable_param_with_default_value(user_texture_id, p_min, p_max, uv_min, uv_max, col);
            },
            nb::arg("user_texture_id"), nb::arg("p_min"), nb::arg("p_max"), nb::arg("uv_min") = nb::none(), nb::arg("uv_max") = nb::none(), nb::arg("col") = IM_COL32_WHITE,
            "---\nPython bindings defaults:\n    If any of the params below is None, then its default value below will be used:\n        uv_min: ImVec2(0, 0)\n        uv_max: ImVec2(1, 1)")
        .def("add_image_quad",
            [](ImDrawList & self, ImTextureID user_texture_id, const ImVec2 & p1, const ImVec2 & p2, const ImVec2 & p3, const ImVec2 & p4, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec2> & uv2 = std::nullopt, const std::optional<const ImVec2> & uv3 = std::nullopt, const std::optional<const ImVec2> & uv4 = std::nullopt, ImU32 col = IM_COL32_WHITE)
            {
                auto AddImageQuad_adapt_mutable_param_with_default_value = [&self](ImTextureID user_texture_id, const ImVec2 & p1, const ImVec2 & p2, const ImVec2 & p3, const ImVec2 & p4, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec2> & uv2 = std::nullopt, const std::optional<const ImVec2> & uv3 = std::nullopt, const std::optional<const ImVec2> & uv4 = std::nullopt, ImU32 col = IM_COL32_WHITE)
                {

                    const ImVec2& uv1_or_default = [&]() -> const ImVec2 {
                        if (uv1.has_value())
                            return uv1.value();
                        else
                            return ImVec2(0, 0);
                    }();

                    const ImVec2& uv2_or_default = [&]() -> const ImVec2 {
                        if (uv2.has_value())
                            return uv2.value();
                        else
                            return ImVec2(1, 0);
                    }();

                    const ImVec2& uv3_or_default = [&]() -> const ImVec2 {
                        if (uv3.has_value())
                            return uv3.value();
                        else
                            return ImVec2(1, 1);
                    }();

                    const ImVec2& uv4_or_default = [&]() -> const ImVec2 {
                        if (uv4.has_value())
                            return uv4.value();
                        else
                            return ImVec2(0, 1);
                    }();

                    self.AddImageQuad(user_texture_id, p1, p2, p3, p4, uv1_or_default, uv2_or_default, uv3_or_default, uv4_or_default, col);
                };

                AddImageQuad_adapt_mutable_param_with_default_value(user_texture_id, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
            },
            nb::arg("user_texture_id"), nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("uv1") = nb::none(), nb::arg("uv2") = nb::none(), nb::arg("uv3") = nb::none(), nb::arg("uv4") = nb::none(), nb::arg("col") = IM_COL32_WHITE,
            "---\nPython bindings defaults:\n    If any of the params below is None, then its default value below will be used:\n        uv1: ImVec2(0, 0)\n        uv2: ImVec2(1, 0)\n        uv3: ImVec2(1, 1)\n        uv4: ImVec2(0, 1)")
        .def("add_image_rounded",
            &ImDrawList::AddImageRounded, nb::arg("user_texture_id"), nb::arg("p_min"), nb::arg("p_max"), nb::arg("uv_min"), nb::arg("uv_max"), nb::arg("col"), nb::arg("rounding"), nb::arg("flags") = 0)
        .def("path_clear",
            &ImDrawList::PathClear, "(private API)")
        .def("path_line_to",
            &ImDrawList::PathLineTo,
            nb::arg("pos"),
            "(private API)")
        .def("path_line_to_merge_duplicate",
            &ImDrawList::PathLineToMergeDuplicate,
            nb::arg("pos"),
            "(private API)")
        .def("path_fill_convex",
            &ImDrawList::PathFillConvex,
            nb::arg("col"),
            "(private API)")
        .def("path_fill_concave",
            &ImDrawList::PathFillConcave,
            nb::arg("col"),
            "(private API)")
        .def("path_stroke",
            &ImDrawList::PathStroke,
            nb::arg("col"), nb::arg("flags") = 0, nb::arg("thickness") = 1.0f,
            "(private API)")
        .def("path_arc_to",
            &ImDrawList::PathArcTo, nb::arg("center"), nb::arg("radius"), nb::arg("a_min"), nb::arg("a_max"), nb::arg("num_segments") = 0)
        .def("path_arc_to_fast",
            &ImDrawList::PathArcToFast,
            nb::arg("center"), nb::arg("radius"), nb::arg("a_min_of_12"), nb::arg("a_max_of_12"),
            "Use precomputed angles for a 12 steps circle")
        .def("path_elliptical_arc_to",
            &ImDrawList::PathEllipticalArcTo,
            nb::arg("center"), nb::arg("radius"), nb::arg("rot"), nb::arg("a_min"), nb::arg("a_max"), nb::arg("num_segments") = 0,
            "Ellipse")
        .def("path_bezier_cubic_curve_to",
            &ImDrawList::PathBezierCubicCurveTo,
            nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("num_segments") = 0,
            "Cubic Bezier (4 control points)")
        .def("path_bezier_quadratic_curve_to",
            &ImDrawList::PathBezierQuadraticCurveTo,
            nb::arg("p2"), nb::arg("p3"), nb::arg("num_segments") = 0,
            "Quadratic Bezier (3 control points)")
        .def("path_rect",
            &ImDrawList::PathRect, nb::arg("rect_min"), nb::arg("rect_max"), nb::arg("rounding") = 0.0f, nb::arg("flags") = 0)
        .def("add_draw_cmd",
            &ImDrawList::AddDrawCmd, "This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible")
        .def("clone_output",
            &ImDrawList::CloneOutput,
            "Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.",
            nb::rv_policy::reference)
        .def("channels_split",
            &ImDrawList::ChannelsSplit,
            nb::arg("count"),
            "(private API)")
        .def("channels_merge",
            &ImDrawList::ChannelsMerge, "(private API)")
        .def("channels_set_current",
            &ImDrawList::ChannelsSetCurrent,
            nb::arg("n"),
            "(private API)")
        .def("prim_reserve",
            &ImDrawList::PrimReserve, nb::arg("idx_count"), nb::arg("vtx_count"))
        .def("prim_unreserve",
            &ImDrawList::PrimUnreserve, nb::arg("idx_count"), nb::arg("vtx_count"))
        .def("prim_rect",
            &ImDrawList::PrimRect,
            nb::arg("a"), nb::arg("b"), nb::arg("col"),
            "Axis aligned rectangle (composed of two triangles)")
        .def("prim_rect_uv",
            &ImDrawList::PrimRectUV, nb::arg("a"), nb::arg("b"), nb::arg("uv_a"), nb::arg("uv_b"), nb::arg("col"))
        .def("prim_quad_uv",
            &ImDrawList::PrimQuadUV, nb::arg("a"), nb::arg("b"), nb::arg("c"), nb::arg("d"), nb::arg("uv_a"), nb::arg("uv_b"), nb::arg("uv_c"), nb::arg("uv_d"), nb::arg("col"))
        .def("prim_write_vtx",
            &ImDrawList::PrimWriteVtx,
            nb::arg("pos"), nb::arg("uv"), nb::arg("col"),
            "(private API)")
        .def("prim_write_idx",
            &ImDrawList::PrimWriteIdx,
            nb::arg("idx"),
            "(private API)")
        .def("prim_vtx",
            &ImDrawList::PrimVtx,
            nb::arg("pos"), nb::arg("uv"), nb::arg("col"),
            "(private API)\n\n Write vertex with unique index")
        .def("_reset_for_new_frame",
            &ImDrawList::_ResetForNewFrame)
        .def("_clear_free_memory",
            &ImDrawList::_ClearFreeMemory)
        .def("_pop_unused_draw_cmd",
            &ImDrawList::_PopUnusedDrawCmd)
        .def("_try_merge_draw_cmds",
            &ImDrawList::_TryMergeDrawCmds)
        .def("_on_changed_clip_rect",
            &ImDrawList::_OnChangedClipRect)
        .def("_on_changed_texture_id",
            &ImDrawList::_OnChangedTextureID)
        .def("_on_changed_vtx_offset",
            &ImDrawList::_OnChangedVtxOffset)
        .def("_set_texture_id",
            &ImDrawList::_SetTextureID, nb::arg("texture_id"))
        .def("_calc_circle_auto_segment_count",
            &ImDrawList::_CalcCircleAutoSegmentCount, nb::arg("radius"))
        .def("_path_arc_to_fast_ex",
            &ImDrawList::_PathArcToFastEx, nb::arg("center"), nb::arg("radius"), nb::arg("a_min_sample"), nb::arg("a_max_sample"), nb::arg("a_step"))
        .def("_path_arc_to_n",
            &ImDrawList::_PathArcToN, nb::arg("center"), nb::arg("radius"), nb::arg("a_min"), nb::arg("a_max"), nb::arg("num_segments"))
        ;


    auto pyClassImDrawData =
        nb::class_<ImDrawData>
            (m, "ImDrawData", " All draw data to render a Dear ImGui frame\n (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,\n as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)")
        .def_rw("valid", &ImDrawData::Valid, "Only valid after Render() is called and before the next NewFrame() is called.")
        .def_rw("cmd_lists_count", &ImDrawData::CmdListsCount, "Number of ImDrawList* to render")
        .def_rw("total_idx_count", &ImDrawData::TotalIdxCount, "For convenience, sum of all ImDrawList's IdxBuffer.Size")
        .def_rw("total_vtx_count", &ImDrawData::TotalVtxCount, "For convenience, sum of all ImDrawList's VtxBuffer.Size")
        .def_rw("cmd_lists", &ImDrawData::CmdLists, "Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.")
        .def_rw("display_pos", &ImDrawData::DisplayPos, "Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)")
        .def_rw("display_size", &ImDrawData::DisplaySize, "Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)")
        .def_rw("framebuffer_scale", &ImDrawData::FramebufferScale, "Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.")
        .def_rw("owner_viewport", &ImDrawData::OwnerViewport, "Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).")
        .def(nb::init<>(),
            "Functions")
        .def("clear",
            &ImDrawData::Clear)
        .def("add_draw_list",
            nb::overload_cast<ImDrawList *>(&ImDrawData::AddDrawList),
            nb::arg("draw_list"),
            "Helper to add an external draw list into an existing ImDrawData.")
        .def("de_index_all_buffers",
            &ImDrawData::DeIndexAllBuffers, "Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!")
        .def("scale_clip_rects",
            &ImDrawData::ScaleClipRects,
            nb::arg("fb_scale"),
            "Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.")
        ;


    auto pyClassImFontConfig =
        nb::class_<ImFontConfig>
            (m, "ImFontConfig", "")
        .def_rw("font_data", &ImFontConfig::FontData, "// TTF/OTF data")
        .def_rw("font_data_size", &ImFontConfig::FontDataSize, "// TTF/OTF data size")
        .def_rw("font_data_owned_by_atlas", &ImFontConfig::FontDataOwnedByAtlas, "True     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).")
        .def_rw("font_no", &ImFontConfig::FontNo, "0        // Index of font within TTF/OTF file")
        .def_rw("size_pixels", &ImFontConfig::SizePixels, "// Size in pixels for rasterizer (more or less maps to the resulting font height).")
        .def_rw("oversample_h", &ImFontConfig::OversampleH, "2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.")
        .def_rw("oversample_v", &ImFontConfig::OversampleV, "1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.")
        .def_rw("pixel_snap_h", &ImFontConfig::PixelSnapH, "False    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.")
        .def_rw("glyph_extra_spacing", &ImFontConfig::GlyphExtraSpacing, "0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.")
        .def_rw("glyph_offset", &ImFontConfig::GlyphOffset, "0, 0     // Offset all glyphs from this font input.")
        .def_rw("glyph_min_advance_x", &ImFontConfig::GlyphMinAdvanceX, "0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font")
        .def_rw("glyph_max_advance_x", &ImFontConfig::GlyphMaxAdvanceX, "FLT_MAX  // Maximum AdvanceX for glyphs")
        .def_rw("merge_mode", &ImFontConfig::MergeMode, "False    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.")
        .def_rw("font_builder_flags", &ImFontConfig::FontBuilderFlags, "0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.")
        .def_rw("rasterizer_multiply", &ImFontConfig::RasterizerMultiply, "1.0     // Linearly brighten (>1.0) or darken (<1.0) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.")
        .def_rw("rasterizer_density", &ImFontConfig::RasterizerDensity, "1.0     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.")
        .def_rw("ellipsis_char", &ImFontConfig::EllipsisChar, "-1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.")
        .def_rw("dst_font", &ImFontConfig::DstFont, "")
        .def(nb::init<>())
        ;


    auto pyClassImFontGlyph =
        nb::class_<ImFontGlyph>
            (m, "ImFontGlyph", " Hold rendering data for one glyph.\n (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)")
        .def("__init__", [](ImFontGlyph * self, float AdvanceX = float(), float X0 = float(), float Y0 = float(), float X1 = float(), float Y1 = float(), float U0 = float(), float V0 = float(), float U1 = float(), float V1 = float())
        {
            new (self) ImFontGlyph();  // placement new
            auto r = self;
            r->AdvanceX = AdvanceX;
            r->X0 = X0;
            r->Y0 = Y0;
            r->X1 = X1;
            r->Y1 = Y1;
            r->U0 = U0;
            r->V0 = V0;
            r->U1 = U1;
            r->V1 = V1;
        },
        nb::arg("advance_x") = float(), nb::arg("x0") = float(), nb::arg("y0") = float(), nb::arg("x1") = float(), nb::arg("y1") = float(), nb::arg("u0") = float(), nb::arg("v0") = float(), nb::arg("u1") = float(), nb::arg("v1") = float()
        )
        .def_rw("advance_x", &ImFontGlyph::AdvanceX, "Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)")
        .def_rw("x0", &ImFontGlyph::X0, "Glyph corners")
        .def_rw("y0", &ImFontGlyph::Y0, "Glyph corners")
        .def_rw("x1", &ImFontGlyph::X1, "Glyph corners")
        .def_rw("y1", &ImFontGlyph::Y1, "Glyph corners")
        .def_rw("u0", &ImFontGlyph::U0, "")
        .def_rw("v0", &ImFontGlyph::V0, "")
        .def_rw("u1", &ImFontGlyph::U1, "")
        .def_rw("v1", &ImFontGlyph::V1, "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("is_colored",
            &ImFontGlyph::isColored, "(private API)")
        .def("is_visible",
            &ImFontGlyph::isVisible, "(private API)")
        .def("get_codepoint",
            &ImFontGlyph::getCodepoint, "(private API)")
        // #endif
        ;


    auto pyClassImFontGlyphRangesBuilder =
        nb::class_<ImFontGlyphRangesBuilder>
            (m, "ImFontGlyphRangesBuilder", " Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().\n This is essentially a tightly packed of vector of 64k booleans = 8KB storage.")
        .def_rw("used_chars", &ImFontGlyphRangesBuilder::UsedChars, "Store 1-bit per Unicode code point (0=unused, 1=used)")
        .def(nb::init<>())
        .def("clear",
            &ImFontGlyphRangesBuilder::Clear, "(private API)")
        .def("get_bit",
            &ImFontGlyphRangesBuilder::GetBit,
            nb::arg("n"),
            "(private API)\n\n Get bit n in the array")
        .def("set_bit",
            &ImFontGlyphRangesBuilder::SetBit,
            nb::arg("n"),
            "(private API)\n\n Set bit n in the array")
        .def("add_char",
            &ImFontGlyphRangesBuilder::AddChar,
            nb::arg("c"),
            "(private API)\n\n Add character")
        .def("add_text",
            [](ImFontGlyphRangesBuilder & self, const char * text, std::optional<std::string> text_end = std::nullopt)
            {
                auto AddText_adapt_const_char_pointer_with_default_null = [&self](const char * text, std::optional<std::string> text_end = std::nullopt)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.AddText(text, text_end_adapt_default_null);
                };

                AddText_adapt_const_char_pointer_with_default_null(text, text_end);
            },
            nb::arg("text"), nb::arg("text_end") = nb::none(),
            "Add string (each character of the UTF-8 string are added)")
        .def("build_ranges",
            &ImFontGlyphRangesBuilder::BuildRanges,
            nb::arg("out_ranges"),
            "Output new ranges")
        ;


    auto pyClassImFontAtlasCustomRect =
        nb::class_<ImFontAtlasCustomRect>
            (m, "ImFontAtlasCustomRect", "See ImFontAtlas::AddCustomRectXXX functions.")
        .def_rw("width", &ImFontAtlasCustomRect::Width, "Input    // Desired rectangle dimension")
        .def_rw("height", &ImFontAtlasCustomRect::Height, "Input    // Desired rectangle dimension")
        .def_rw("x", &ImFontAtlasCustomRect::X, "Output   // Packed position in Atlas")
        .def_rw("y", &ImFontAtlasCustomRect::Y, "Output   // Packed position in Atlas")
        .def_rw("glyph_id", &ImFontAtlasCustomRect::GlyphID, "Input    // For custom font glyphs only (ID < 0x110000)")
        .def_rw("glyph_advance_x", &ImFontAtlasCustomRect::GlyphAdvanceX, "Input    // For custom font glyphs only: glyph xadvance")
        .def_rw("glyph_offset", &ImFontAtlasCustomRect::GlyphOffset, "Input    // For custom font glyphs only: glyph display offset")
        .def_rw("font", &ImFontAtlasCustomRect::Font, "Input    // For custom font glyphs only: target font")
        .def(nb::init<>())
        .def("is_packed",
            &ImFontAtlasCustomRect::IsPacked, "(private API)")
        ;


    auto pyEnumImFontAtlasFlags_ =
        nb::enum_<ImFontAtlasFlags_>(m, "ImFontAtlasFlags_", nb::is_arithmetic(), "Flags for ImFontAtlas build")
            .value("none", ImFontAtlasFlags_None, "")
            .value("no_power_of_two_height", ImFontAtlasFlags_NoPowerOfTwoHeight, "Don't round the height to next power of two")
            .value("no_mouse_cursors", ImFontAtlasFlags_NoMouseCursors, "Don't build software mouse cursors into the atlas (save a little texture memory)")
            .value("no_baked_lines", ImFontAtlasFlags_NoBakedLines, "Don't build thick line textures into the atlas (save a little texture memory, allow support for point/nearest filtering). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).");


    auto pyClassImFontAtlas =
        nb::class_<ImFontAtlas>
            (m, "ImFontAtlas", " Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:\n  - One or more fonts.\n  - Custom graphics data needed to render the shapes needed by Dear ImGui.\n  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).\n It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.\n  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.\n  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.\n  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)\n  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.\n    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.\n Common pitfalls:\n - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the\n   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.\n - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.\n   You can set font_cfg->FontDataOwnedByAtlas=False to keep ownership of your data and it won't be freed,\n - Even though many functions are suffixed with \"TTF\", OTF data is supported just as well.\n - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!")
        .def(nb::init<>())
        .def("add_font",
            &ImFontAtlas::AddFont,
            nb::arg("font_cfg"),
            nb::rv_policy::reference)
        .def("add_font_default",
            &ImFontAtlas::AddFontDefault,
            nb::arg("font_cfg") = nb::none(),
            nb::rv_policy::reference)
        .def("clear_input_data",
            &ImFontAtlas::ClearInputData, "Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.")
        .def("clear_tex_data",
            &ImFontAtlas::ClearTexData, "Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.")
        .def("clear_fonts",
            &ImFontAtlas::ClearFonts, "Clear output font data (glyphs storage, UV coordinates).")
        .def("clear",
            &ImFontAtlas::Clear, "Clear all input and output.")
        .def("build",
            &ImFontAtlas::Build, "Build pixels data. This is called automatically for you by the GetTexData*** functions.")
        .def("is_built",
            &ImFontAtlas::IsBuilt, "(private API)\n\n Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...")
        .def("set_tex_id",
            &ImFontAtlas::SetTexID,
            nb::arg("id_"),
            "(private API)")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("add_font_from_file_ttf",
            &ImFontAtlas::_AddFontFromFileTTF,
            nb::arg("filename"), nb::arg("size_pixels"), nb::arg("font_cfg") = nb::none(), nb::arg("glyph_ranges_as_int_list") = nb::none(),
            nb::rv_policy::reference)
        .def("get_glyph_ranges_default",
            &ImFontAtlas::_GetGlyphRangesDefault, "// Basic Latin, Extended Latin")
        .def("get_glyph_ranges_greek",
            &ImFontAtlas::_GetGlyphRangesGreek, "// Default + Greek and Coptic")
        .def("get_glyph_ranges_korean",
            &ImFontAtlas::_GetGlyphRangesKorean, "// Default + Korean characters")
        .def("get_glyph_ranges_japanese",
            &ImFontAtlas::_GetGlyphRangesJapanese, "// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs")
        .def("get_glyph_ranges_chinese_full",
            &ImFontAtlas::_GetGlyphRangesChineseFull, "// Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs")
        .def("get_glyph_ranges_chinese_simplified_common",
            &ImFontAtlas::_GetGlyphRangesChineseSimplifiedCommon, "// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese")
        .def("get_glyph_ranges_cyrillic",
            &ImFontAtlas::_GetGlyphRangesCyrillic, "// Default + about 400 Cyrillic characters")
        .def("get_glyph_ranges_thai",
            &ImFontAtlas::_GetGlyphRangesThai, "// Default + Thai characters")
        .def("get_glyph_ranges_vietnamese",
            &ImFontAtlas::_GetGlyphRangesVietnamese, "// Default + Vietnamese characters")
        // #endif
        //
        .def("add_custom_rect_regular",
            &ImFontAtlas::AddCustomRectRegular, nb::arg("width"), nb::arg("height"))
        .def("add_custom_rect_font_glyph",
            [](ImFontAtlas & self, ImFont * font, ImWchar id, int width, int height, float advance_x, const std::optional<const ImVec2> & offset = std::nullopt) -> int
            {
                auto AddCustomRectFontGlyph_adapt_mutable_param_with_default_value = [&self](ImFont * font, ImWchar id, int width, int height, float advance_x, const std::optional<const ImVec2> & offset = std::nullopt) -> int
                {

                    const ImVec2& offset_or_default = [&]() -> const ImVec2 {
                        if (offset.has_value())
                            return offset.value();
                        else
                            return ImVec2(0, 0);
                    }();

                    auto lambda_result = self.AddCustomRectFontGlyph(font, id, width, height, advance_x, offset_or_default);
                    return lambda_result;
                };

                return AddCustomRectFontGlyph_adapt_mutable_param_with_default_value(font, id, width, height, advance_x, offset);
            },
            nb::arg("font"), nb::arg("id_"), nb::arg("width"), nb::arg("height"), nb::arg("advance_x"), nb::arg("offset") = nb::none(),
            "---\nPython bindings defaults:\n    If offset is None, then its default value will be: ImVec2(0, 0)")
        .def("get_custom_rect_by_index",
            &ImFontAtlas::GetCustomRectByIndex,
            nb::arg("index"),
            "(private API)",
            nb::rv_policy::reference)
        .def("calc_custom_rect_uv",
            &ImFontAtlas::CalcCustomRectUV, nb::arg("rect"), nb::arg("out_uv_min"), nb::arg("out_uv_max"))
        .def("get_mouse_cursor_tex_data",
            &ImFontAtlas::GetMouseCursorTexData, nb::arg("cursor"), nb::arg("out_offset"), nb::arg("out_size"), nb::arg("out_uv_border"), nb::arg("out_uv_fill"))
        .def_rw("flags", &ImFontAtlas::Flags, "Build flags (see ImFontAtlasFlags_)")
        .def_rw("tex_id", &ImFontAtlas::TexID, "User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.")
        .def_rw("tex_desired_width", &ImFontAtlas::TexDesiredWidth, "Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.")
        .def_rw("tex_glyph_padding", &ImFontAtlas::TexGlyphPadding, "Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = False).")
        .def_rw("locked", &ImFontAtlas::Locked, "Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.")
        .def_rw("user_data", &ImFontAtlas::UserData, "Store your own atlas related user-data (if e.g. you have multiple font atlas).")
        .def_rw("tex_ready", &ImFontAtlas::TexReady, "Set when texture was built matching current font input")
        .def_rw("tex_pixels_use_colors", &ImFontAtlas::TexPixelsUseColors, "Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.")
        .def_rw("tex_width", &ImFontAtlas::TexWidth, "Texture width calculated during Build().")
        .def_rw("tex_height", &ImFontAtlas::TexHeight, "Texture height calculated during Build().")
        .def_rw("tex_uv_scale", &ImFontAtlas::TexUvScale, "= (1.0/TexWidth, 1.0/TexHeight)")
        .def_rw("tex_uv_white_pixel", &ImFontAtlas::TexUvWhitePixel, "Texture coordinates to a white pixel")
        .def_rw("fonts", &ImFontAtlas::Fonts, "Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.")
        .def_rw("custom_rects", &ImFontAtlas::CustomRects, "Rectangles for packing custom texture data into the atlas.")
        .def_rw("config_data", &ImFontAtlas::ConfigData, "Configuration data")
        .def_ro("font_builder_io", &ImFontAtlas::FontBuilderIO, "Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).")
        .def_rw("font_builder_flags", &ImFontAtlas::FontBuilderFlags, "Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.")
        .def_rw("pack_id_mouse_cursors", &ImFontAtlas::PackIdMouseCursors, "Custom texture rectangle ID for white pixel and mouse cursors")
        .def_rw("pack_id_lines", &ImFontAtlas::PackIdLines, "Custom texture rectangle ID for baked anti-aliased lines")
        ;


    auto pyClassImFont =
        nb::class_<ImFont>
            (m, "ImFont", " Font runtime data and rendering\n ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().")
        .def_rw("index_advance_x", &ImFont::IndexAdvanceX, "12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).")
        .def_rw("fallback_advance_x", &ImFont::FallbackAdvanceX, "4     // out // = FallbackGlyph->AdvanceX")
        .def_rw("font_size", &ImFont::FontSize, "4     // in  //            // Height of characters/line, set during loading (don't change after loading)")
        .def_rw("index_lookup", &ImFont::IndexLookup, "12-16 // out //            // Sparse. Index glyphs by Unicode code-point.")
        .def_rw("glyphs", &ImFont::Glyphs, "12-16 // out //            // All glyphs.")
        .def_ro("fallback_glyph", &ImFont::FallbackGlyph, "4-8   // out // = FindGlyph(FontFallbackChar)")
        .def_rw("container_atlas", &ImFont::ContainerAtlas, "4-8   // out //            // What we has been loaded into")
        .def_ro("config_data", &ImFont::ConfigData, "4-8   // in  //            // Pointer within ContainerAtlas->ConfigData")
        .def_rw("config_data_count", &ImFont::ConfigDataCount, "2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.")
        .def_rw("fallback_char", &ImFont::FallbackChar, "2     // out // = FFFD/'?' // Character used if a glyph isn't found.")
        .def_rw("ellipsis_char", &ImFont::EllipsisChar, "2     // out // = '...'/'.'// Character used for ellipsis rendering.")
        .def_rw("ellipsis_char_count", &ImFont::EllipsisCharCount, "1     // out // 1 or 3")
        .def_rw("ellipsis_width", &ImFont::EllipsisWidth, "4     // out               // Width")
        .def_rw("ellipsis_char_step", &ImFont::EllipsisCharStep, "4     // out               // Step between characters when EllipsisCount > 0")
        .def_rw("dirty_lookup_tables", &ImFont::DirtyLookupTables, "1     // out //")
        .def_rw("scale", &ImFont::Scale, "4     // in  // = 1.      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()")
        .def_rw("ascent", &ImFont::Ascent, "4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)")
        .def_rw("descent", &ImFont::Descent, "4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)")
        .def_rw("metrics_total_surface", &ImFont::MetricsTotalSurface, "4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)")
        .def(nb::init<>(),
            "Methods")
        .def("find_glyph",
            &ImFont::FindGlyph,
            nb::arg("c"),
            nb::rv_policy::reference)
        .def("find_glyph_no_fallback",
            &ImFont::FindGlyphNoFallback,
            nb::arg("c"),
            nb::rv_policy::reference)
        .def("get_char_advance",
            &ImFont::GetCharAdvance,
            nb::arg("c"),
            "(private API)")
        .def("is_loaded",
            &ImFont::IsLoaded, "(private API)")
        .def("get_debug_name",
            &ImFont::GetDebugName,
            "(private API)",
            nb::rv_policy::reference)
        .def("calc_word_wrap_position_a",
            &ImFont::CalcWordWrapPositionA,
            nb::arg("scale"), nb::arg("text"), nb::arg("text_end"), nb::arg("wrap_width"),
            nb::rv_policy::reference)
        .def("render_char",
            &ImFont::RenderChar, nb::arg("draw_list"), nb::arg("size"), nb::arg("pos"), nb::arg("col"), nb::arg("c"))
        .def("render_text",
            &ImFont::RenderText, nb::arg("draw_list"), nb::arg("size"), nb::arg("pos"), nb::arg("col"), nb::arg("clip_rect"), nb::arg("text_begin"), nb::arg("text_end"), nb::arg("wrap_width") = 0.0f, nb::arg("cpu_fine_clip") = false)
        .def("build_lookup_table",
            &ImFont::BuildLookupTable)
        .def("clear_output_data",
            &ImFont::ClearOutputData)
        .def("grow_index",
            &ImFont::GrowIndex, nb::arg("new_size"))
        .def("add_glyph",
            &ImFont::AddGlyph, nb::arg("src_cfg"), nb::arg("c"), nb::arg("x0"), nb::arg("y0"), nb::arg("x1"), nb::arg("y1"), nb::arg("u0"), nb::arg("v0"), nb::arg("u1"), nb::arg("v1"), nb::arg("advance_x"))
        .def("add_remap_char",
            &ImFont::AddRemapChar,
            nb::arg("dst"), nb::arg("src"), nb::arg("overwrite_dst") = true,
            "Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.")
        .def("set_glyph_visible",
            &ImFont::SetGlyphVisible, nb::arg("c"), nb::arg("visible"))
        .def("is_glyph_range_unused",
            &ImFont::IsGlyphRangeUnused, nb::arg("c_begin"), nb::arg("c_last"))
        ;


    auto pyEnumViewportFlags_ =
        nb::enum_<ImGuiViewportFlags_>(m, "ViewportFlags_", nb::is_arithmetic(), "Flags stored in ImGuiViewport::Flags, giving indications to the platform backends.")
            .value("none", ImGuiViewportFlags_None, "")
            .value("is_platform_window", ImGuiViewportFlags_IsPlatformWindow, "Represent a Platform Window")
            .value("is_platform_monitor", ImGuiViewportFlags_IsPlatformMonitor, "Represent a Platform Monitor (unused yet)")
            .value("owned_by_app", ImGuiViewportFlags_OwnedByApp, "Platform Window: Is created/managed by the user application? (rather than our backend)")
            .value("no_decoration", ImGuiViewportFlags_NoDecoration, "Platform Window: Disable platform decorations: title bar, borders, etc. (generally set all windows, but if ImGuiConfigFlags_ViewportsDecoration is set we only set this on popups/tooltips)")
            .value("no_task_bar_icon", ImGuiViewportFlags_NoTaskBarIcon, "Platform Window: Disable platform task bar icon (generally set on popups/tooltips, or all windows if ImGuiConfigFlags_ViewportsNoTaskBarIcon is set)")
            .value("no_focus_on_appearing", ImGuiViewportFlags_NoFocusOnAppearing, "Platform Window: Don't take focus when created.")
            .value("no_focus_on_click", ImGuiViewportFlags_NoFocusOnClick, "Platform Window: Don't take focus when clicked on.")
            .value("no_inputs", ImGuiViewportFlags_NoInputs, "Platform Window: Make mouse pass through so we can drag this window while peaking behind it.")
            .value("no_renderer_clear", ImGuiViewportFlags_NoRendererClear, "Platform Window: Renderer doesn't need to clear the framebuffer ahead (because we will fill it entirely).")
            .value("no_auto_merge", ImGuiViewportFlags_NoAutoMerge, "Platform Window: Avoid merging this window into another host window. This can only be set via ImGuiWindowClass viewport flags override (because we need to now ahead if we are going to create a viewport in the first place!).")
            .value("top_most", ImGuiViewportFlags_TopMost, "Platform Window: Display on top (for tooltips only).")
            .value("can_host_other_windows", ImGuiViewportFlags_CanHostOtherWindows, "Viewport can host multiple imgui windows (secondary viewports are associated to a single window). // FIXME: In practice there's still probably code making the assumption that this is always and only on the MainViewport. Will fix once we add support for \"no main viewport\".")
            .value("is_minimized", ImGuiViewportFlags_IsMinimized, "Platform Window: Window is minimized, can skip render. When minimized we tend to avoid using the viewport pos/size for clipping window or testing if they are contained in the viewport.")
            .value("is_focused", ImGuiViewportFlags_IsFocused, "Platform Window: Window is focused (last call to Platform_GetWindowFocus() returned True)");


    auto pyClassImGuiViewport =
        nb::class_<ImGuiViewport>
            (m, "Viewport", " - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.\n - With multi-viewport enabled, we extend this concept to have multiple active viewports.\n - In the future we will extend this concept further to also represent Platform Monitor and support a \"no main platform window\" operation mode.\n - About Main Area vs Work Area:\n   - Main Area = entire viewport.\n   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).\n   - Windows are generally trying to stay within the Work Area of their host viewport.")
        .def_rw("id_", &ImGuiViewport::ID, "Unique identifier for the viewport")
        .def_rw("flags", &ImGuiViewport::Flags, "See ImGuiViewportFlags_")
        .def_rw("pos", &ImGuiViewport::Pos, "Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)")
        .def_rw("size", &ImGuiViewport::Size, "Main Area: Size of the viewport.")
        .def_rw("work_pos", &ImGuiViewport::WorkPos, "Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)")
        .def_rw("work_size", &ImGuiViewport::WorkSize, "Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)")
        .def_rw("dpi_scale", &ImGuiViewport::DpiScale, "1.0 = 96 DPI = No extra scale.")
        .def_rw("parent_viewport_id", &ImGuiViewport::ParentViewportId, "(Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows.")
        .def_rw("draw_data", &ImGuiViewport::DrawData, "The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().")
        .def_rw("renderer_user_data", &ImGuiViewport::RendererUserData, "None* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.")
        .def_rw("platform_user_data", &ImGuiViewport::PlatformUserData, "None* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.")
        .def_rw("platform_handle", &ImGuiViewport::PlatformHandle, "None* to hold higher-level, platform window handle (e.g. HWND, GLFWWindow*, SDL_Window*), for FindViewportByPlatformHandle().")
        .def_rw("platform_handle_raw", &ImGuiViewport::PlatformHandleRaw, "None* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)")
        .def_rw("platform_window_created", &ImGuiViewport::PlatformWindowCreated, "Platform window has been created (Platform_CreateWindow() has been called). This is False during the first frame where a viewport is being created.")
        .def_rw("platform_request_move", &ImGuiViewport::PlatformRequestMove, "Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)")
        .def_rw("platform_request_resize", &ImGuiViewport::PlatformRequestResize, "Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)")
        .def_rw("platform_request_close", &ImGuiViewport::PlatformRequestClose, "Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)")
        .def(nb::init<>())
        .def("get_center",
            &ImGuiViewport::GetCenter, "(private API)")
        .def("get_work_center",
            &ImGuiViewport::GetWorkCenter, "(private API)")
        ;


    auto pyClassImGuiPlatformIO =
        nb::class_<ImGuiPlatformIO>
            (m, "PlatformIO", "Access via ImGui::GetPlatformIO()")
        .def(nb::init<>())
        .def_rw("platform_get_clipboard_text_fn", &ImGuiPlatformIO::Platform_GetClipboardTextFn, "")
        .def_rw("platform_set_clipboard_text_fn", &ImGuiPlatformIO::Platform_SetClipboardTextFn, "")
        .def_rw("platform_clipboard_user_data", &ImGuiPlatformIO::Platform_ClipboardUserData, "[/ADAPT_IMGUI_BUNDLE]")
        .def_rw("platform_open_in_shell_fn", &ImGuiPlatformIO::Platform_OpenInShellFn, " Optional: Open link/folder/file in OS Shell\n (default to use ShellExecuteA() on Windows, system() on Linux/Mac)\n [ADAPT_IMGUI_BUNDLE]\nbool        (*Platform_OpenInShellFn)(ImGuiContext* ctx, const char* path);")
        .def_rw("platform_open_in_shell_user_data", &ImGuiPlatformIO::Platform_OpenInShellUserData, "[/ADAPT_IMGUI_BUNDLE]")
        .def_rw("platform_ime_user_data", &ImGuiPlatformIO::Platform_ImeUserData, "")
        .def_rw("platform_locale_decimal_point", &ImGuiPlatformIO::Platform_LocaleDecimalPoint, "'.'")
        .def_rw("renderer_render_state", &ImGuiPlatformIO::Renderer_RenderState, "Written by some backends during ImGui_ImplXXXX_RenderDrawData() call to point backend_specific ImGui_ImplXXXX_RenderState* structure.")
        .def_rw("monitors", &ImGuiPlatformIO::Monitors, " (Optional) Monitor list\n - Updated by: app/backend. Update every frame to dynamically support changing monitor or DPI configuration.\n - Used by: dear imgui to query DPI info, clamp popups/tooltips within same monitor and not have them straddle monitors.")
        .def_rw("viewports", &ImGuiPlatformIO::Viewports, "Main viewports, followed by all secondary viewports.")
        ;


    auto pyClassImGuiPlatformMonitor =
        nb::class_<ImGuiPlatformMonitor>
            (m, "PlatformMonitor", " (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.\n We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.")
        .def_rw("main_pos", &ImGuiPlatformMonitor::MainPos, "Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)")
        .def_rw("main_size", &ImGuiPlatformMonitor::MainSize, "Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)")
        .def_rw("work_pos", &ImGuiPlatformMonitor::WorkPos, "Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.")
        .def_rw("work_size", &ImGuiPlatformMonitor::WorkSize, "Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.")
        .def_rw("dpi_scale", &ImGuiPlatformMonitor::DpiScale, "1.0 = 96 DPI")
        .def_rw("platform_handle", &ImGuiPlatformMonitor::PlatformHandle, "Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)")
        .def(nb::init<>())
        ;


    auto pyClassImGuiPlatformImeData =
        nb::class_<ImGuiPlatformImeData>
            (m, "PlatformImeData", "(Optional) Support for IME (Input Method Editor) via the platform_io.Platform_SetImeDataFn() function.")
        .def_rw("want_visible", &ImGuiPlatformImeData::WantVisible, "A widget wants the IME to be visible")
        .def_rw("input_pos", &ImGuiPlatformImeData::InputPos, "Position of the input cursor")
        .def_rw("input_line_height", &ImGuiPlatformImeData::InputLineHeight, "Line height")
        .def(nb::init<>())
        ;
    // #ifdef IMGUI_INCLUDE_IMGUI_USER_H
    //
    // #endif
    //
    // #endif
    ////////////////////    </generated_from:imgui.h>    ////////////////////


    ////////////////////    <generated_from:imgui_stacklayout.h>    ////////////////////
    // #ifndef IMGUI_DISABLE
    //


    m.def("begin_horizontal",
        [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginHorizontal_adapt_mutable_param_with_default_value = [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginHorizontal(str_id, size_or_default, align);
            };

            BeginHorizontal_adapt_mutable_param_with_default_value(str_id, size, align);
        },
        nb::arg("str_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_horizontal",
        [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginHorizontal_adapt_mutable_param_with_default_value = [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginHorizontal(ptr_id, size_or_default, align);
            };

            BeginHorizontal_adapt_mutable_param_with_default_value(ptr_id, size, align);
        },
        nb::arg("ptr_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_horizontal",
        [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
        {
            auto BeginHorizontal_adapt_mutable_param_with_default_value = [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginHorizontal(id, size_or_default, align);
            };

            BeginHorizontal_adapt_mutable_param_with_default_value(id, size, align);
        },
        nb::arg("id_"), nb::arg("size") = nb::none(), nb::arg("align") = -1,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("end_horizontal",
        ImGui::EndHorizontal);

    m.def("begin_vertical",
        [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginVertical_adapt_mutable_param_with_default_value = [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginVertical(str_id, size_or_default, align);
            };

            BeginVertical_adapt_mutable_param_with_default_value(str_id, size, align);
        },
        nb::arg("str_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_vertical",
        [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginVertical_adapt_mutable_param_with_default_value = [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginVertical(ptr_id, size_or_default, align);
            };

            BeginVertical_adapt_mutable_param_with_default_value(ptr_id, size, align);
        },
        nb::arg("ptr_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_vertical",
        [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
        {
            auto BeginVertical_adapt_mutable_param_with_default_value = [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginVertical(id, size_or_default, align);
            };

            BeginVertical_adapt_mutable_param_with_default_value(id, size, align);
        },
        nb::arg("id_"), nb::arg("size") = nb::none(), nb::arg("align") = -1,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("end_vertical",
        ImGui::EndVertical);

    m.def("spring",
        ImGui::Spring, nb::arg("weight") = 1.0f, nb::arg("spacing") = -1.0f);

    m.def("suspend_layout",
        ImGui::SuspendLayout);

    m.def("resume_layout",
        ImGui::ResumeLayout);
    // #endif
    ////////////////////    </generated_from:imgui_stacklayout.h>    ////////////////////


    ////////////////////    <generated_from:imgui_stacklayout_internal.h>    ////////////////////
    // #ifndef IMGUI_DISABLE
    //
    // #endif
    ////////////////////    </generated_from:imgui_stacklayout_internal.h>    ////////////////////


    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // ****************************************************************************************************************
    //
    //             MANUAL PATCHES BELOW
    //
    // ****************************************************************************************************************

    // FLT_MIN & FLT_MAX
    m.attr("FLT_MIN") = (float)FLT_MIN;
    m.attr("FLT_MAX") = (float)FLT_MAX;


    //
    //  Patches to ImFontAtlas
    //
    // make imgui.font_atlas_get_tex_data_as_rgba32() also accessible
    // as imgui.get_io().fonts.get_tex_data_as_rgba32(), even if autocomplete
    // doesn't find the latter.
// Function to retrieve RGBA32 texture data as a numpy array
    auto font_atlas_get_tex_data_as_rgba32 = [](ImFontAtlas* self) -> nb::handle
    {
        unsigned char *pixels = nullptr;
        int width = 0, height = 0, bytes_per_pixel = 0;

        // Retrieve texture data from ImFontAtlas
        self->GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);

        if (!pixels || width <= 0 || height <= 0 || bytes_per_pixel != 4)
            throw std::runtime_error("Invalid texture data retrieved from ImFontAtlas.");

        // The returned data is a pointer to the texture data, which is owned by the ImFontAtlas.
        // so, we set the owner to the ImFontAtlas object to ensure that the data is not deallocated
        nb::object owner = nb::cast(self);

        // Create and return the ndarray using the initializer list constructor
        // We will use this constructor:
        auto font_as_array = nb::ndarray<uint8_t>(
            pixels,                  // VoidPtr data
            {(size_t)height, (size_t)width, (size_t)4},      // Shape
            owner,                  // Owner
            {(int64_t)(4 * width), (int64_t)4, (int64_t)1},       // Strides in **elements** (not bytes)
            nb::dtype<uint8_t>(),    // Data type
            0,                       // device_type (default to CPU)
            0,                       // device_id (default to 0)
            'C'                      // Order ('C' for C-contiguous)
        );

        // Properly export the ndarray
        return nb::detail::ndarray_export(
            font_as_array.handle(),
            nb::numpy::value,
            nb::rv_policy::move, // Transfer ownership to Python (which will manage the lifetime of the ndarray, and the capsule will manage the lifetime of the data)
            nullptr // cleanup
        );
    };
    m.def("font_atlas_get_tex_data_as_rgba32", font_atlas_get_tex_data_as_rgba32);
    pyClassImFontAtlas.def("get_tex_data_as_rgba32", font_atlas_get_tex_data_as_rgba32);

    //
    //  Other patches
    //

    // VERTEX_SIZE, VERTEX_BUFFER_POS_OFFSET, VERTEX_BUFFER_UV_OFFSET, etc.
    // Utilities to facilitate rendering in python backends: they provide buffer offsets info
    //
    //    def _py_vertex_buffer_vertex_size():
    //    return sizeof(cimgui.ImDrawVert)
    m.attr("VERTEX_SIZE") = sizeof(ImDrawVert);
    //    def _py_vertex_buffer_vertex_pos_offset():
    //    return <uintptr_t><size_t>&(<cimgui.ImDrawVert*>NULL).pos
    ImDrawVert* nullDrawVert = NULL;
    m.attr("VERTEX_BUFFER_POS_OFFSET") = (uintptr_t)(size_t) (& (nullDrawVert->pos));
    //    def _py_vertex_buffer_vertex_uv_offset():
    //    return <uintptr_t><size_t>&(<cimgui.ImDrawVert*>NULL).uv
    m.attr("VERTEX_BUFFER_UV_OFFSET") = (uintptr_t)(size_t) (& (nullDrawVert->uv));
    //    def _py_vertex_buffer_vertex_col_offset():
    //    return <uintptr_t><size_t>&(<cimgui.ImDrawVert*>NULL).col
    m.attr("VERTEX_BUFFER_COL_OFFSET") = (uintptr_t)(size_t) (& (nullDrawVert->col));
    //    def _py_index_buffer_index_size():
    //    return sizeof(cimgui.ImDrawIdx)
    m.attr("INDEX_SIZE") = sizeof(ImDrawIdx);


    m.def("IM_COL32", [](int r, int g, int b, int a){
       return IM_COL32(r, g, b, a);
    });

    // API for imgui_demo
    // ------------------
    // Forward declarations of imgui_demo.cpp API
    void SetImGuiDemoWindowPos(ImVec2 pos, ImVec2 size, ImGuiCond cond);
    void SetImGuiDemoCodeWindowPos(ImVec2 pos, ImVec2 size, ImGuiCond cond);
    void ImGuiDemoSetShowPythonCode(bool showPythonCode);
    extern bool GImGuiDemoMarker_IsActive;
    // Expose imgui_demo.cpp API
    m.def("set_imgui_demo_window_pos", SetImGuiDemoWindowPos);
    m.def("set_imgui_demo_code_window_pos", SetImGuiDemoCodeWindowPos);
    m.def("set_imgui_demo_marker_is_active", [](bool b) { GImGuiDemoMarker_IsActive = b; });
    m.def("get_imgui_demo_marker_is_active", []() { return GImGuiDemoMarker_IsActive; });
    m.def("set_imgui_demo_show_python_code", ImGuiDemoSetShowPythonCode);
}
