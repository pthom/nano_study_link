// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2024 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>


namespace nb = nanobind;


#include "imgui.h"
#include "imgui_internal.h"

using uint = unsigned int;
using uchar = unsigned char;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void nanobind_imgui_part2(nb::module_& m)
{
    auto pyClassImVector_int =
        nb::class_<ImVector<int>>
            (m, "ImVector_int", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<int>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<int> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<int>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<int>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<int>::empty, "(private API)")
        .def("size",
            &ImVector<int>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<int>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<int>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<int>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<int>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<int>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<int> &v) {
                return nb::make_iterator(nb::type<ImVector<int>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<int> &v) { return v.size(); })
        ;
    auto pyClassImVector_uint =
        nb::class_<ImVector<uint>>
            (m, "ImVector_uint", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<uint>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<uint> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<uint>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<uint>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<uint>::empty, "(private API)")
        .def("size",
            &ImVector<uint>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uint>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uint>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<uint>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<uint>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<uint>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<uint> &v) {
                return nb::make_iterator(nb::type<ImVector<uint>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<uint> &v) { return v.size(); })
        ;
    auto pyClassImVector_float =
        nb::class_<ImVector<float>>
            (m, "ImVector_float", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<float>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<float> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<float>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<float>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<float>::empty, "(private API)")
        .def("size",
            &ImVector<float>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<float>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<float>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<float>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<float>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<float>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<float> &v) {
                return nb::make_iterator(nb::type<ImVector<float>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<float> &v) { return v.size(); })
        ;
    auto pyClassImVector_char =
        nb::class_<ImVector<char>>
            (m, "ImVector_char", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<char>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<char> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<char>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<char>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<char>::empty, "(private API)")
        .def("size",
            &ImVector<char>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<char>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<char>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<char>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<char>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<char>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<char> &v) {
                return nb::make_iterator(nb::type<ImVector<char>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<char> &v) { return v.size(); })
        ;
    auto pyClassImVector_uchar =
        nb::class_<ImVector<uchar>>
            (m, "ImVector_uchar", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<uchar>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<uchar> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<uchar>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<uchar>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<uchar>::empty, "(private API)")
        .def("size",
            &ImVector<uchar>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uchar>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<uchar>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<uchar>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<uchar>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<uchar>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<uchar> &v) {
                return nb::make_iterator(nb::type<ImVector<uchar>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<uchar> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawCmd =
        nb::class_<ImVector<ImDrawCmd>>
            (m, "ImVector_ImDrawCmd", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawCmd>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawCmd> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawCmd>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawCmd>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawCmd>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawCmd>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawCmd>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawCmd>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawCmd>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawCmd>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawCmd>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawCmd> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawCmd>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawCmd> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawChannel =
        nb::class_<ImVector<ImDrawChannel>>
            (m, "ImVector_ImDrawChannel", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawChannel>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawChannel> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawChannel>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawChannel>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawChannel>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawChannel>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawChannel>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawChannel>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawChannel>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawChannel>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawChannel>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawChannel> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawChannel>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawChannel> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawVert =
        nb::class_<ImVector<ImDrawVert>>
            (m, "ImVector_ImDrawVert", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawVert>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawVert> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawVert>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawVert>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawVert>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawVert>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawVert>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawVert>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawVert>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawVert>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawVert>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawVert> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawVert>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawVert> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImVec4 =
        nb::class_<ImVector<ImVec4>>
            (m, "ImVector_ImVec4", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImVec4>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImVec4> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImVec4>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImVec4>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImVec4>::empty, "(private API)")
        .def("size",
            &ImVector<ImVec4>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec4>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec4>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImVec4>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImVec4>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImVec4>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImVec4> &v) {
                return nb::make_iterator(nb::type<ImVector<ImVec4>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImVec4> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImVec2 =
        nb::class_<ImVector<ImVec2>>
            (m, "ImVector_ImVec2", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImVec2>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImVec2> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImVec2>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImVec2>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImVec2>::empty, "(private API)")
        .def("size",
            &ImVector<ImVec2>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec2>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImVec2>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImVec2>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImVec2>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImVec2>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImVec2> &v) {
                return nb::make_iterator(nb::type<ImVector<ImVec2>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImVec2> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImDrawList_ptr =
        nb::class_<ImVector<ImDrawList *>>
            (m, "ImVector_ImDrawList_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImDrawList *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImDrawList *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImDrawList *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImDrawList *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImDrawList *>::empty, "(private API)")
        .def("size",
            &ImVector<ImDrawList *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawList *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImDrawList *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImDrawList *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImDrawList *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImDrawList *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImDrawList *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImDrawList *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImDrawList *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFont_ptr =
        nb::class_<ImVector<ImFont *>>
            (m, "ImVector_ImFont_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFont *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFont *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFont *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFont *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFont *>::empty, "(private API)")
        .def("size",
            &ImVector<ImFont *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFont *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFont *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFont *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFont *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFont *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFont *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFont *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFont *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFontGlyph =
        nb::class_<ImVector<ImFontGlyph>>
            (m, "ImVector_ImFontGlyph", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFontGlyph>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFontGlyph> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFontGlyph>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFontGlyph>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFontGlyph>::empty, "(private API)")
        .def("size",
            &ImVector<ImFontGlyph>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontGlyph>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontGlyph>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFontGlyph>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFontGlyph>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFontGlyph>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFontGlyph> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFontGlyph>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFontGlyph> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiPlatformMonitor =
        nb::class_<ImVector<ImGuiPlatformMonitor>>
            (m, "ImVector_PlatformMonitor", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiPlatformMonitor>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiPlatformMonitor> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiPlatformMonitor>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiPlatformMonitor>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiPlatformMonitor>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiPlatformMonitor>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPlatformMonitor>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPlatformMonitor>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiPlatformMonitor>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiPlatformMonitor>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiPlatformMonitor>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiPlatformMonitor> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiPlatformMonitor>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiPlatformMonitor> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiViewport_ptr =
        nb::class_<ImVector<ImGuiViewport *>>
            (m, "ImVector_Viewport_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiViewport *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiViewport *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiViewport *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiViewport *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiViewport *>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiViewport *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewport *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewport *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiViewport *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiViewport *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiViewport *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiViewport *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiViewport *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiViewport *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiWindow_ptr =
        nb::class_<ImVector<ImGuiWindow *>>
            (m, "ImVector_Window_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiWindow *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiWindow *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiWindow *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiWindow *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiWindow *>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiWindow *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindow *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindow *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiWindow *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiWindow *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiWindow *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiWindow *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiWindow *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiWindow *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFontAtlasCustomRect =
        nb::class_<ImVector<ImFontAtlasCustomRect>>
            (m, "ImVector_ImFontAtlasCustomRect", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFontAtlasCustomRect>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFontAtlasCustomRect> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFontAtlasCustomRect>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFontAtlasCustomRect>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFontAtlasCustomRect>::empty, "(private API)")
        .def("size",
            &ImVector<ImFontAtlasCustomRect>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontAtlasCustomRect>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontAtlasCustomRect>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFontAtlasCustomRect>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFontAtlasCustomRect>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFontAtlasCustomRect>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFontAtlasCustomRect> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFontAtlasCustomRect>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFontAtlasCustomRect> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImFontConfig =
        nb::class_<ImVector<ImFontConfig>>
            (m, "ImVector_ImFontConfig", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImFontConfig>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImFontConfig> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImFontConfig>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImFontConfig>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImFontConfig>::empty, "(private API)")
        .def("size",
            &ImVector<ImFontConfig>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontConfig>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImFontConfig>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImFontConfig>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImFontConfig>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImFontConfig>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImFontConfig> &v) {
                return nb::make_iterator(nb::type<ImVector<ImFontConfig>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImFontConfig> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiFocusScopeData =
        nb::class_<ImVector<ImGuiFocusScopeData>>
            (m, "ImVector_FocusScopeData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiFocusScopeData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiFocusScopeData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiFocusScopeData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiFocusScopeData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiFocusScopeData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiFocusScopeData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiFocusScopeData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiFocusScopeData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiFocusScopeData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiFocusScopeData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiFocusScopeData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiFocusScopeData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiFocusScopeData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiFocusScopeData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiSelectionRequest =
        nb::class_<ImVector<ImGuiSelectionRequest>>
            (m, "ImVector_SelectionRequest", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiSelectionRequest>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiSelectionRequest> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiSelectionRequest>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiSelectionRequest>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiSelectionRequest>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiSelectionRequest>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSelectionRequest>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSelectionRequest>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiSelectionRequest>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiSelectionRequest>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiSelectionRequest>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiSelectionRequest> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiSelectionRequest>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiSelectionRequest> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImRect =
        nb::class_<ImVector<ImRect>>
            (m, "ImVector_ImRect", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImRect>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImRect> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImRect>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImRect>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImRect>::empty, "(private API)")
        .def("size",
            &ImVector<ImRect>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImRect>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImRect>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImRect>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImRect>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImRect>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImRect> &v) {
                return nb::make_iterator(nb::type<ImVector<ImRect>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImRect> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiColorMod =
        nb::class_<ImVector<ImGuiColorMod>>
            (m, "ImVector_ColorMod", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiColorMod>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiColorMod> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiColorMod>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiColorMod>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiColorMod>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiColorMod>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiColorMod>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiColorMod>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiColorMod>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiColorMod>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiColorMod>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiColorMod> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiColorMod>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiColorMod> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiGroupData =
        nb::class_<ImVector<ImGuiGroupData>>
            (m, "ImVector_GroupData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiGroupData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiGroupData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiGroupData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiGroupData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiGroupData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiGroupData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiGroupData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiGroupData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiGroupData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiGroupData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiGroupData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiGroupData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiGroupData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiGroupData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiPopupData =
        nb::class_<ImVector<ImGuiPopupData>>
            (m, "ImVector_PopupData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiPopupData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiPopupData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiPopupData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiPopupData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiPopupData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiPopupData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPopupData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPopupData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiPopupData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiPopupData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiPopupData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiPopupData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiPopupData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiPopupData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiViewportP_ptr =
        nb::class_<ImVector<ImGuiViewportP *>>
            (m, "ImVector_ViewportP_ptr", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiViewportP *>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiViewportP *> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiViewportP *>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiViewportP *>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiViewportP *>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiViewportP *>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewportP *>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiViewportP *>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiViewportP *>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiViewportP *>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiViewportP *>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiViewportP *> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiViewportP *>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiViewportP *> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiInputEvent =
        nb::class_<ImVector<ImGuiInputEvent>>
            (m, "ImVector_InputEvent", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiInputEvent>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiInputEvent> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiInputEvent>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiInputEvent>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiInputEvent>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiInputEvent>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiInputEvent>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiInputEvent>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiInputEvent>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiInputEvent>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiInputEvent>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiInputEvent> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiInputEvent>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiInputEvent> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiWindowStackData =
        nb::class_<ImVector<ImGuiWindowStackData>>
            (m, "ImVector_WindowStackData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiWindowStackData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiWindowStackData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiWindowStackData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiWindowStackData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiWindowStackData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiWindowStackData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindowStackData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiWindowStackData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiWindowStackData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiWindowStackData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiWindowStackData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiWindowStackData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiWindowStackData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiWindowStackData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableColumnSortSpecs =
        nb::class_<ImVector<ImGuiTableColumnSortSpecs>>
            (m, "ImVector_TableColumnSortSpecs", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableColumnSortSpecs>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableColumnSortSpecs> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableColumnSortSpecs>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableColumnSortSpecs>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableColumnSortSpecs>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableColumnSortSpecs>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableColumnSortSpecs>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableColumnSortSpecs>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableColumnSortSpecs>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableColumnSortSpecs>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableColumnSortSpecs>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableColumnSortSpecs> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableColumnSortSpecs>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableColumnSortSpecs> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableInstanceData =
        nb::class_<ImVector<ImGuiTableInstanceData>>
            (m, "ImVector_TableInstanceData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableInstanceData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableInstanceData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableInstanceData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableInstanceData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableInstanceData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableInstanceData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableInstanceData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableInstanceData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableInstanceData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableInstanceData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableInstanceData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableInstanceData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableInstanceData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableInstanceData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableTempData =
        nb::class_<ImVector<ImGuiTableTempData>>
            (m, "ImVector_TableTempData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableTempData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableTempData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableTempData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableTempData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableTempData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableTempData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableTempData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableTempData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableTempData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableTempData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableTempData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableTempData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableTempData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableTempData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiPtrOrIndex =
        nb::class_<ImVector<ImGuiPtrOrIndex>>
            (m, "ImVector_PtrOrIndex", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiPtrOrIndex>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiPtrOrIndex> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiPtrOrIndex>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiPtrOrIndex>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiPtrOrIndex>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiPtrOrIndex>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPtrOrIndex>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiPtrOrIndex>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiPtrOrIndex>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiPtrOrIndex>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiPtrOrIndex>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiPtrOrIndex> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiPtrOrIndex>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiPtrOrIndex> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiSettingsHandler =
        nb::class_<ImVector<ImGuiSettingsHandler>>
            (m, "ImVector_SettingsHandler", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiSettingsHandler>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiSettingsHandler> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiSettingsHandler>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiSettingsHandler>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiSettingsHandler>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiSettingsHandler>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSettingsHandler>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiSettingsHandler>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiSettingsHandler>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiSettingsHandler>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiSettingsHandler>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiSettingsHandler> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiSettingsHandler>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiSettingsHandler> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiShrinkWidthItem =
        nb::class_<ImVector<ImGuiShrinkWidthItem>>
            (m, "ImVector_ShrinkWidthItem", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiShrinkWidthItem>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiShrinkWidthItem> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiShrinkWidthItem>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiShrinkWidthItem>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiShrinkWidthItem>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiShrinkWidthItem>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiShrinkWidthItem>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiShrinkWidthItem>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiShrinkWidthItem>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiShrinkWidthItem>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiShrinkWidthItem>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiShrinkWidthItem> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiShrinkWidthItem>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiShrinkWidthItem> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiStackLevelInfo =
        nb::class_<ImVector<ImGuiStackLevelInfo>>
            (m, "ImVector_StackLevelInfo", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiStackLevelInfo>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiStackLevelInfo> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiStackLevelInfo>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiStackLevelInfo>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiStackLevelInfo>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiStackLevelInfo>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStackLevelInfo>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStackLevelInfo>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiStackLevelInfo>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiStackLevelInfo>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiStackLevelInfo>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiStackLevelInfo> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiStackLevelInfo>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiStackLevelInfo> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTabItem =
        nb::class_<ImVector<ImGuiTabItem>>
            (m, "ImVector_TabItem", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTabItem>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTabItem> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTabItem>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTabItem>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTabItem>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTabItem>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTabItem>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTabItem>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTabItem>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTabItem>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTabItem>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTabItem> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTabItem>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTabItem> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiKeyRoutingData =
        nb::class_<ImVector<ImGuiKeyRoutingData>>
            (m, "ImVector_KeyRoutingData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiKeyRoutingData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiKeyRoutingData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiKeyRoutingData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiKeyRoutingData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiKeyRoutingData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiKeyRoutingData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiKeyRoutingData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiKeyRoutingData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiKeyRoutingData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiKeyRoutingData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiKeyRoutingData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiKeyRoutingData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiKeyRoutingData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiKeyRoutingData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiListClipperData =
        nb::class_<ImVector<ImGuiListClipperData>>
            (m, "ImVector_ListClipperData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiListClipperData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiListClipperData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiListClipperData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiListClipperData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiListClipperData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiListClipperData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiListClipperData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiListClipperData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiListClipperData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiListClipperData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiListClipperData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiListClipperData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiListClipperRange =
        nb::class_<ImVector<ImGuiListClipperRange>>
            (m, "ImVector_ListClipperRange", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiListClipperRange>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiListClipperRange> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiListClipperRange>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiListClipperRange>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiListClipperRange>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiListClipperRange>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperRange>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiListClipperRange>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiListClipperRange>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiListClipperRange>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiListClipperRange>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiListClipperRange> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiListClipperRange>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiListClipperRange> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiOldColumnData =
        nb::class_<ImVector<ImGuiOldColumnData>>
            (m, "ImVector_OldColumnData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiOldColumnData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiOldColumnData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiOldColumnData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiOldColumnData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiOldColumnData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiOldColumnData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumnData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumnData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiOldColumnData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiOldColumnData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiOldColumnData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiOldColumnData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiOldColumnData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiOldColumnData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiOldColumns =
        nb::class_<ImVector<ImGuiOldColumns>>
            (m, "ImVector_OldColumns", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiOldColumns>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiOldColumns> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiOldColumns>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiOldColumns>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiOldColumns>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiOldColumns>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumns>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiOldColumns>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiOldColumns>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiOldColumns>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiOldColumns>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiOldColumns> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiOldColumns>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiOldColumns> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiStyleMod =
        nb::class_<ImVector<ImGuiStyleMod>>
            (m, "ImVector_StyleMod", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiStyleMod>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiStyleMod> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiStyleMod>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiStyleMod>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiStyleMod>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiStyleMod>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStyleMod>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiStyleMod>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiStyleMod>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiStyleMod>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiStyleMod>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiStyleMod> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiStyleMod>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiStyleMod> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTableHeaderData =
        nb::class_<ImVector<ImGuiTableHeaderData>>
            (m, "ImVector_TableHeaderData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTableHeaderData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTableHeaderData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTableHeaderData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTableHeaderData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTableHeaderData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTableHeaderData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableHeaderData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTableHeaderData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTableHeaderData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTableHeaderData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTableHeaderData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTableHeaderData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTableHeaderData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTableHeaderData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiTreeNodeStackData =
        nb::class_<ImVector<ImGuiTreeNodeStackData>>
            (m, "ImVector_TreeNodeStackData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiTreeNodeStackData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiTreeNodeStackData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiTreeNodeStackData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiTreeNodeStackData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiTreeNodeStackData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiTreeNodeStackData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTreeNodeStackData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiTreeNodeStackData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiTreeNodeStackData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiTreeNodeStackData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiTreeNodeStackData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiTreeNodeStackData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiTreeNodeStackData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiTreeNodeStackData> &v) { return v.size(); })
        ;
    auto pyClassImVector_ImGuiMultiSelectTempData =
        nb::class_<ImVector<ImGuiMultiSelectTempData>>
            (m, "ImVector_MultiSelectTempData", "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("data_address",
            &ImVector<ImGuiMultiSelectTempData>::DataAddress, "(private API)")
        // #endif
        //
        .def(nb::init<>())
        .def(nb::init<const ImVector<ImGuiMultiSelectTempData> &>(),
            nb::arg("src"))
        .def("clear",
            &ImVector<ImGuiMultiSelectTempData>::clear, " Important: does not destruct anything\n(private API)")
        .def("clear_destruct",
            &ImVector<ImGuiMultiSelectTempData>::clear_destruct, " Important: never called automatically! always explicit.\n(private API)")
        .def("empty",
            &ImVector<ImGuiMultiSelectTempData>::empty, "(private API)")
        .def("size",
            &ImVector<ImGuiMultiSelectTempData>::size, "(private API)")
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiMultiSelectTempData>::operator[], nb::const_),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<int>(&ImVector<ImGuiMultiSelectTempData>::operator[]),
            nb::arg("i"),
            "(private API)",
            nb::rv_policy::reference)
        .def("push_back",
            &ImVector<ImGuiMultiSelectTempData>::push_back,
            nb::arg("v"),
            "(private API)")
        .def("pop_back",
            &ImVector<ImGuiMultiSelectTempData>::pop_back, "(private API)")
        .def("push_front",
            &ImVector<ImGuiMultiSelectTempData>::push_front,
            nb::arg("v"),
            "(private API)")
        .def("__iter__", [](const ImVector<ImGuiMultiSelectTempData> &v) {
                return nb::make_iterator(nb::type<ImVector<ImGuiMultiSelectTempData>>(), "iterator", v.begin(), v.end());
            }, nb::keep_alive<0, 1>())
        .def("__len__", [](const ImVector<ImGuiMultiSelectTempData> &v) { return v.size(); })
        ;


    auto pyClassImGuiStyle =
        nb::class_<ImGuiStyle>
            (m, "Style", "")
        .def_rw("alpha", &ImGuiStyle::Alpha, "Global alpha applies to everything in Dear ImGui.")
        .def_rw("disabled_alpha", &ImGuiStyle::DisabledAlpha, "Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.")
        .def_rw("window_padding", &ImGuiStyle::WindowPadding, "Padding within a window.")
        .def_rw("window_rounding", &ImGuiStyle::WindowRounding, "Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.")
        .def_rw("window_border_size", &ImGuiStyle::WindowBorderSize, "Thickness of border around windows. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("window_min_size", &ImGuiStyle::WindowMinSize, "Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().")
        .def_rw("window_title_align", &ImGuiStyle::WindowTitleAlign, "Alignment for title bar text. Defaults to (0.0,0.5) for left-aligned,vertically centered.")
        .def_rw("window_menu_button_position", &ImGuiStyle::WindowMenuButtonPosition, "Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.")
        .def_rw("child_rounding", &ImGuiStyle::ChildRounding, "Radius of child window corners rounding. Set to 0.0 to have rectangular windows.")
        .def_rw("child_border_size", &ImGuiStyle::ChildBorderSize, "Thickness of border around child windows. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("popup_rounding", &ImGuiStyle::PopupRounding, "Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)")
        .def_rw("popup_border_size", &ImGuiStyle::PopupBorderSize, "Thickness of border around popup/tooltip windows. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("frame_padding", &ImGuiStyle::FramePadding, "Padding within a framed rectangle (used by most widgets).")
        .def_rw("frame_rounding", &ImGuiStyle::FrameRounding, "Radius of frame corners rounding. Set to 0.0 to have rectangular frame (used by most widgets).")
        .def_rw("frame_border_size", &ImGuiStyle::FrameBorderSize, "Thickness of border around frames. Generally set to 0.0 or 1.0. (Other values are not well tested and more CPU/GPU costly).")
        .def_rw("item_spacing", &ImGuiStyle::ItemSpacing, "Horizontal and vertical spacing between widgets/lines.")
        .def_rw("item_inner_spacing", &ImGuiStyle::ItemInnerSpacing, "Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).")
        .def_rw("cell_padding", &ImGuiStyle::CellPadding, "Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.")
        .def_rw("touch_extra_padding", &ImGuiStyle::TouchExtraPadding, "Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!")
        .def_rw("indent_spacing", &ImGuiStyle::IndentSpacing, "Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).")
        .def_rw("columns_min_spacing", &ImGuiStyle::ColumnsMinSpacing, "Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).")
        .def_rw("scrollbar_size", &ImGuiStyle::ScrollbarSize, "Width of the vertical scrollbar, Height of the horizontal scrollbar.")
        .def_rw("scrollbar_rounding", &ImGuiStyle::ScrollbarRounding, "Radius of grab corners for scrollbar.")
        .def_rw("grab_min_size", &ImGuiStyle::GrabMinSize, "Minimum width/height of a grab box for slider/scrollbar.")
        .def_rw("grab_rounding", &ImGuiStyle::GrabRounding, "Radius of grabs corners rounding. Set to 0.0 to have rectangular slider grabs.")
        .def_rw("layout_align", &ImGuiStyle::LayoutAlign, "Element alignment inside horizontal and vertical layouts (0.0 - left/top, 1.0 - right/bottom, 0.5 - center).")
        .def_rw("log_slider_deadzone", &ImGuiStyle::LogSliderDeadzone, "The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.")
        .def_rw("tab_rounding", &ImGuiStyle::TabRounding, "Radius of upper corners of a tab. Set to 0.0 to have rectangular tabs.")
        .def_rw("tab_border_size", &ImGuiStyle::TabBorderSize, "Thickness of border around tabs.")
        .def_rw("tab_min_width_for_close_button", &ImGuiStyle::TabMinWidthForCloseButton, "Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0 to always show when hovering, set to FLT_MAX to never show close button unless selected.")
        .def_rw("tab_bar_border_size", &ImGuiStyle::TabBarBorderSize, "Thickness of tab-bar separator, which takes on the tab active color to denote focus.")
        .def_rw("tab_bar_overline_size", &ImGuiStyle::TabBarOverlineSize, "Thickness of tab-bar overline, which highlights the selected tab-bar.")
        .def_rw("table_angled_headers_angle", &ImGuiStyle::TableAngledHeadersAngle, "Angle of angled headers (supported values range from -50.0 degrees to +50.0 degrees).")
        .def_rw("table_angled_headers_text_align", &ImGuiStyle::TableAngledHeadersTextAlign, "Alignment of angled headers within the cell")
        .def_rw("color_button_position", &ImGuiStyle::ColorButtonPosition, "Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.")
        .def_rw("button_text_align", &ImGuiStyle::ButtonTextAlign, "Alignment of button text when button is larger than text. Defaults to (0.5, 0.5) (centered).")
        .def_rw("selectable_text_align", &ImGuiStyle::SelectableTextAlign, "Alignment of selectable text. Defaults to (0.0, 0.0) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.")
        .def_rw("separator_text_border_size", &ImGuiStyle::SeparatorTextBorderSize, "Thickness of border in SeparatorText()")
        .def_rw("separator_text_align", &ImGuiStyle::SeparatorTextAlign, "Alignment of text within the separator. Defaults to (0.0, 0.5) (left aligned, center).")
        .def_rw("separator_text_padding", &ImGuiStyle::SeparatorTextPadding, "Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.")
        .def_rw("display_window_padding", &ImGuiStyle::DisplayWindowPadding, "Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.")
        .def_rw("display_safe_area_padding", &ImGuiStyle::DisplaySafeAreaPadding, "Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).")
        .def_rw("docking_separator_size", &ImGuiStyle::DockingSeparatorSize, "Thickness of resizing border between docked windows")
        .def_rw("mouse_cursor_scale", &ImGuiStyle::MouseCursorScale, "Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.")
        .def_rw("anti_aliased_lines", &ImGuiStyle::AntiAliasedLines, "Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).")
        .def_rw("anti_aliased_lines_use_tex", &ImGuiStyle::AntiAliasedLinesUseTex, "Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).")
        .def_rw("anti_aliased_fill", &ImGuiStyle::AntiAliasedFill, "Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).")
        .def_rw("curve_tessellation_tol", &ImGuiStyle::CurveTessellationTol, "Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.")
        .def_rw("circle_tessellation_max_error", &ImGuiStyle::CircleTessellationMaxError, "Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.")
        .def_rw("hover_stationary_delay", &ImGuiStyle::HoverStationaryDelay, "Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.")
        .def_rw("hover_delay_short", &ImGuiStyle::HoverDelayShort, "Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.")
        .def_rw("hover_delay_normal", &ImGuiStyle::HoverDelayNormal, "Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). \"")
        .def_rw("hover_flags_for_tooltip_mouse", &ImGuiStyle::HoverFlagsForTooltipMouse, "Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.")
        .def_rw("hover_flags_for_tooltip_nav", &ImGuiStyle::HoverFlagsForTooltipNav, "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("color_",
            &ImGuiStyle::Color_,
            nb::arg("idx_color"),
            nb::rv_policy::reference)
        .def("set_color_",
            &ImGuiStyle::SetColor_, nb::arg("idx_color"), nb::arg("color"))
        // #endif
        //
        .def(nb::init<>())
        .def("scale_all_sizes",
            &ImGuiStyle::ScaleAllSizes, nb::arg("scale_factor"))
        ;


    auto pyClassImGuiKeyData =
        nb::class_<ImGuiKeyData>
            (m, "KeyData", " [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.\n If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.")
        .def("__init__", [](ImGuiKeyData * self, bool Down = bool(), float DownDuration = float(), float DownDurationPrev = float(), float AnalogValue = float())
        {
            new (self) ImGuiKeyData();  // placement new
            auto r = self;
            r->Down = Down;
            r->DownDuration = DownDuration;
            r->DownDurationPrev = DownDurationPrev;
            r->AnalogValue = AnalogValue;
        },
        nb::arg("down") = bool(), nb::arg("down_duration") = float(), nb::arg("down_duration_prev") = float(), nb::arg("analog_value") = float()
        )
        .def_rw("down", &ImGuiKeyData::Down, "True for if key is down")
        .def_rw("down_duration", &ImGuiKeyData::DownDuration, "Duration the key has been down (<0.0: not pressed, 0.0: just pressed, >0.0: time held)")
        .def_rw("down_duration_prev", &ImGuiKeyData::DownDurationPrev, "Last frame duration the key has been down")
        .def_rw("analog_value", &ImGuiKeyData::AnalogValue, "0.0..1.0 for gamepad values")
        ;


    auto pyClassImGuiIO =
        nb::class_<ImGuiIO>
            (m, "IO", "")
        .def_rw("config_flags", &ImGuiIO::ConfigFlags, "= 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.")
        .def_rw("backend_flags", &ImGuiIO::BackendFlags, "= 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.")
        .def_rw("display_size", &ImGuiIO::DisplaySize, "<unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.")
        .def_rw("delta_time", &ImGuiIO::DeltaTime, "= 1.0/60.0     // Time elapsed since last frame, in seconds. May change every frame.")
        .def_rw("ini_saving_rate", &ImGuiIO::IniSavingRate, "")
        .def_rw("user_data", &ImGuiIO::UserData, "= None           // Store your own data.")
        .def_rw("fonts", &ImGuiIO::Fonts, "<auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.")
        .def_rw("font_global_scale", &ImGuiIO::FontGlobalScale, "= 1.0           // Global scale all fonts")
        .def_rw("font_allow_user_scaling", &ImGuiIO::FontAllowUserScaling, "= False          // Allow user scaling text of individual window with CTRL+Wheel.")
        .def_rw("font_default", &ImGuiIO::FontDefault, "= None           // Font to use on NewFrame(). Use None to uses Fonts->Fonts[0].")
        .def_rw("display_framebuffer_scale", &ImGuiIO::DisplayFramebufferScale, "= (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.")
        .def_rw("config_nav_swap_gamepad_buttons", &ImGuiIO::ConfigNavSwapGamepadButtons, "= False          // Swap Activate<>Cancel (A<>B) buttons, matching typical \"Nintendo/Japanese style\" gamepad layout.")
        .def_rw("config_nav_move_set_mouse_pos", &ImGuiIO::ConfigNavMoveSetMousePos, "= False          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=True.")
        .def_rw("config_nav_capture_keyboard", &ImGuiIO::ConfigNavCaptureKeyboard, "= True           // Sets io.WantCaptureKeyboard when io.NavActive is set.")
        .def_rw("config_nav_escape_clear_focus_item", &ImGuiIO::ConfigNavEscapeClearFocusItem, "= True           // Pressing Escape can clear focused item + navigation id/highlight. Set to False if you want to always keep highlight on.")
        .def_rw("config_nav_escape_clear_focus_window", &ImGuiIO::ConfigNavEscapeClearFocusWindow, "= False          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).")
        .def_rw("config_nav_cursor_visible_auto", &ImGuiIO::ConfigNavCursorVisibleAuto, "= True           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.")
        .def_rw("config_nav_cursor_visible_always", &ImGuiIO::ConfigNavCursorVisibleAlways, "= False          // Navigation cursor is always visible.")
        .def_rw("config_docking_no_split", &ImGuiIO::ConfigDockingNoSplit, "= False          // Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.")
        .def_rw("config_docking_with_shift", &ImGuiIO::ConfigDockingWithShift, "= False          // Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)")
        .def_rw("config_docking_always_tab_bar", &ImGuiIO::ConfigDockingAlwaysTabBar, "= False          // [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.")
        .def_rw("config_docking_transparent_payload", &ImGuiIO::ConfigDockingTransparentPayload, "= False          // [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.")
        .def_rw("config_viewports_no_auto_merge", &ImGuiIO::ConfigViewportsNoAutoMerge, "= False;         // Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.")
        .def_rw("config_viewports_no_task_bar_icon", &ImGuiIO::ConfigViewportsNoTaskBarIcon, "= False          // Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.")
        .def_rw("config_viewports_no_decoration", &ImGuiIO::ConfigViewportsNoDecoration, "= True           // Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).")
        .def_rw("config_viewports_no_default_parent", &ImGuiIO::ConfigViewportsNoDefaultParent, "= False          // Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = <main_viewport>, expecting the platform backend to setup a parent/child relationship between the OS windows (some backend may ignore this). Set to True if you want the default to be 0, then all viewports will be top-level OS windows.")
        .def_rw("mouse_draw_cursor", &ImGuiIO::MouseDrawCursor, "= False          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.")
        .def_rw("config_mac_osx_behaviors", &ImGuiIO::ConfigMacOSXBehaviors, "= defined(__APPLE__) // Swap Cmd<>Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.")
        .def_rw("config_input_trickle_event_queue", &ImGuiIO::ConfigInputTrickleEventQueue, "= True           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.")
        .def_rw("config_input_text_cursor_blink", &ImGuiIO::ConfigInputTextCursorBlink, "= True           // Enable blinking cursor (optional as some users consider it to be distracting).")
        .def_rw("config_input_text_enter_keep_active", &ImGuiIO::ConfigInputTextEnterKeepActive, "= False          // [BETA] Pressing Enter will keep item active and select contents (single-line only).")
        .def_rw("config_drag_click_to_input_text", &ImGuiIO::ConfigDragClickToInputText, "= False          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.")
        .def_rw("config_windows_resize_from_edges", &ImGuiIO::ConfigWindowsResizeFromEdges, "= True           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)")
        .def_rw("config_windows_move_from_title_bar_only", &ImGuiIO::ConfigWindowsMoveFromTitleBarOnly, "= False      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.")
        .def_rw("config_scrollbar_scroll_by_page", &ImGuiIO::ConfigScrollbarScrollByPage, "= True           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.")
        .def_rw("config_memory_compact_timer", &ImGuiIO::ConfigMemoryCompactTimer, "= 60.0          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0 to disable.")
        .def_rw("mouse_double_click_time", &ImGuiIO::MouseDoubleClickTime, "= 0.30          // Time for a double-click, in seconds.")
        .def_rw("mouse_double_click_max_dist", &ImGuiIO::MouseDoubleClickMaxDist, "= 6.0           // Distance threshold to stay in to validate a double-click, in pixels.")
        .def_rw("mouse_drag_threshold", &ImGuiIO::MouseDragThreshold, "= 6.0           // Distance threshold before considering we are dragging.")
        .def_rw("key_repeat_delay", &ImGuiIO::KeyRepeatDelay, "= 0.275         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).")
        .def_rw("key_repeat_rate", &ImGuiIO::KeyRepeatRate, "= 0.050         // When holding a key/button, rate at which it repeats, in seconds.")
        .def_rw("config_error_recovery", &ImGuiIO::ConfigErrorRecovery, "= True       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.")
        .def_rw("config_error_recovery_enable_assert", &ImGuiIO::ConfigErrorRecoveryEnableAssert, "= True       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()")
        .def_rw("config_error_recovery_enable_debug_log", &ImGuiIO::ConfigErrorRecoveryEnableDebugLog, "= True       // Enable debug log output on recoverable errors.")
        .def_rw("config_error_recovery_enable_tooltip", &ImGuiIO::ConfigErrorRecoveryEnableTooltip, "= True       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.")
        .def_rw("config_debug_is_debugger_present", &ImGuiIO::ConfigDebugIsDebuggerPresent, "= False          // Enable various tools calling IM_DEBUG_BREAK().")
        .def_rw("config_debug_highlight_id_conflicts", &ImGuiIO::ConfigDebugHighlightIdConflicts, "= True           // Highlight and show an error message when multiple items have conflicting identifiers.")
        .def_rw("config_debug_begin_return_value_once", &ImGuiIO::ConfigDebugBeginReturnValueOnce, "= False          // First-time calls to Begin()/BeginChild() will return False. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.")
        .def_rw("config_debug_begin_return_value_loop", &ImGuiIO::ConfigDebugBeginReturnValueLoop, "= False          // Some calls to Begin()/BeginChild() will return False. Will cycle through window depths then repeat. Suggested use: add \"io.ConfigDebugBeginReturnValue = io.KeyShift\" in your main loop then occasionally press SHIFT. Windows should be flickering while running.")
        .def_rw("config_debug_ignore_focus_loss", &ImGuiIO::ConfigDebugIgnoreFocusLoss, "= False          // Ignore io.AddFocusEvent(False), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.")
        .def_rw("config_debug_ini_settings", &ImGuiIO::ConfigDebugIniSettings, "= False          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)")
        .def_ro("backend_platform_name", &ImGuiIO::BackendPlatformName, "= None")
        .def_ro("backend_renderer_name", &ImGuiIO::BackendRendererName, "= None")
        .def_rw("backend_platform_user_data", &ImGuiIO::BackendPlatformUserData, "= None           // User data for platform backend")
        .def_rw("backend_renderer_user_data", &ImGuiIO::BackendRendererUserData, "= None           // User data for renderer backend")
        .def_rw("backend_language_user_data", &ImGuiIO::BackendLanguageUserData, "= None           // User data for non C++ programming language backend")
        .def("add_key_event",
            &ImGuiIO::AddKeyEvent,
            nb::arg("key"), nb::arg("down"),
            "Queue a new key down/up event. Key should be \"translated\" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)")
        .def("add_key_analog_event",
            &ImGuiIO::AddKeyAnalogEvent,
            nb::arg("key"), nb::arg("down"), nb::arg("v"),
            "Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.")
        .def("add_mouse_pos_event",
            &ImGuiIO::AddMousePosEvent,
            nb::arg("x"), nb::arg("y"),
            "Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)")
        .def("add_mouse_button_event",
            &ImGuiIO::AddMouseButtonEvent,
            nb::arg("button"), nb::arg("down"),
            "Queue a mouse button change")
        .def("add_mouse_wheel_event",
            &ImGuiIO::AddMouseWheelEvent,
            nb::arg("wheel_x"), nb::arg("wheel_y"),
            "Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.")
        .def("add_mouse_source_event",
            &ImGuiIO::AddMouseSourceEvent,
            nb::arg("source"),
            "Queue a mouse source change (Mouse/TouchScreen/Pen)")
        .def("add_mouse_viewport_event",
            &ImGuiIO::AddMouseViewportEvent,
            nb::arg("id_"),
            "Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).")
        .def("add_focus_event",
            &ImGuiIO::AddFocusEvent,
            nb::arg("focused"),
            "Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)")
        .def("add_input_character",
            &ImGuiIO::AddInputCharacter,
            nb::arg("c"),
            "Queue a new character input")
        .def("add_input_character_utf16",
            &ImGuiIO::AddInputCharacterUTF16,
            nb::arg("c"),
            "Queue a new character input from a UTF-16 character, it can be a surrogate")
        .def("add_input_characters_utf8",
            &ImGuiIO::AddInputCharactersUTF8,
            nb::arg("str"),
            "Queue a new characters input from a UTF-8 string")
        .def("set_key_event_native_data",
            &ImGuiIO::SetKeyEventNativeData,
            nb::arg("key"), nb::arg("native_keycode"), nb::arg("native_scancode"), nb::arg("native_legacy_index") = -1,
            "[Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.")
        .def("set_app_accepting_events",
            &ImGuiIO::SetAppAcceptingEvents,
            nb::arg("accepting_events"),
            "Set master flag for accepting key/mouse/text events (default to True). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.")
        .def("clear_events_queue",
            &ImGuiIO::ClearEventsQueue, "Clear all incoming events.")
        .def("clear_input_keys",
            &ImGuiIO::ClearInputKeys, "Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.")
        .def("clear_input_mouse",
            &ImGuiIO::ClearInputMouse)
        .def_rw("want_capture_mouse", &ImGuiIO::WantCaptureMouse, "Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).")
        .def_rw("want_capture_keyboard", &ImGuiIO::WantCaptureKeyboard, "Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).")
        .def_rw("want_text_input", &ImGuiIO::WantTextInput, "Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).")
        .def_rw("want_set_mouse_pos", &ImGuiIO::WantSetMousePos, "MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.")
        .def_rw("want_save_ini_settings", &ImGuiIO::WantSaveIniSettings, "When manual .ini load/save is active (io.IniFilename == None), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!")
        .def_rw("nav_active", &ImGuiIO::NavActive, "Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.")
        .def_rw("nav_visible", &ImGuiIO::NavVisible, "Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).")
        .def_rw("framerate", &ImGuiIO::Framerate, "Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.")
        .def_rw("metrics_render_vertices", &ImGuiIO::MetricsRenderVertices, "Vertices output during last call to Render()")
        .def_rw("metrics_render_indices", &ImGuiIO::MetricsRenderIndices, "Indices output during last call to Render() = number of triangles * 3")
        .def_rw("metrics_render_windows", &ImGuiIO::MetricsRenderWindows, "Number of visible windows")
        .def_rw("metrics_active_windows", &ImGuiIO::MetricsActiveWindows, "Number of active windows")
        .def_rw("mouse_delta", &ImGuiIO::MouseDelta, "Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.")
        .def_rw("ctx", &ImGuiIO::Ctx, "Parent UI context (needs to be set explicitly by parent).")
        .def_rw("mouse_pos", &ImGuiIO::MousePos, "Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)")
        .def_prop_ro("mouse_down",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDown;
            },
            "Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.")
        .def_rw("mouse_wheel", &ImGuiIO::MouseWheel, "Mouse wheel Vertical: 1 unit scrolls about 5 lines text. >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.")
        .def_rw("mouse_wheel_h", &ImGuiIO::MouseWheelH, "Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.")
        .def_rw("mouse_source", &ImGuiIO::MouseSource, "Mouse actual input peripheral (Mouse/TouchScreen/Pen).")
        .def_rw("mouse_hovered_viewport", &ImGuiIO::MouseHoveredViewport, "(Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).")
        .def_rw("key_ctrl", &ImGuiIO::KeyCtrl, "Keyboard modifier down: Control")
        .def_rw("key_shift", &ImGuiIO::KeyShift, "Keyboard modifier down: Shift")
        .def_rw("key_alt", &ImGuiIO::KeyAlt, "Keyboard modifier down: Alt")
        .def_rw("key_super", &ImGuiIO::KeySuper, "Keyboard modifier down: Cmd/Super/Windows")
        .def_rw("key_mods", &ImGuiIO::KeyMods, "Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()")
        .def_rw("want_capture_mouse_unless_popup_close", &ImGuiIO::WantCaptureMouseUnlessPopupClose, "Alternative to WantCaptureMouse: (WantCaptureMouse == True && WantCaptureMouseUnlessPopupClose == False) when a click over None is expected to close a popup.")
        .def_rw("mouse_pos_prev", &ImGuiIO::MousePosPrev, "Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)")
        .def_prop_ro("mouse_clicked_time",
            [](ImGuiIO &self) -> nb::ndarray<double, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClickedTime;
            },
            "Time of last click (used to figure out double-click)")
        .def_prop_ro("mouse_clicked",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClicked;
            },
            "Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)")
        .def_prop_ro("mouse_double_clicked",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDoubleClicked;
            },
            "Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)")
        .def_prop_ro("mouse_clicked_count",
            [](ImGuiIO &self) -> nb::ndarray<ImU16, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClickedCount;
            },
            "== 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down")
        .def_prop_ro("mouse_clicked_last_count",
            [](ImGuiIO &self) -> nb::ndarray<ImU16, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseClickedLastCount;
            },
            "Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.")
        .def_prop_ro("mouse_released",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseReleased;
            },
            "Mouse button went from Down to !Down")
        .def_prop_ro("mouse_down_owned",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownOwned;
            },
            "Track if button was clicked inside a dear imgui window or over None blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.")
        .def_prop_ro("mouse_down_owned_unless_popup_close",
            [](ImGuiIO &self) -> nb::ndarray<bool, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownOwnedUnlessPopupClose;
            },
            "Track if button was clicked inside a dear imgui window.")
        .def_rw("mouse_wheel_request_axis_swap", &ImGuiIO::MouseWheelRequestAxisSwap, "On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.")
        .def_rw("mouse_ctrl_left_as_right_click", &ImGuiIO::MouseCtrlLeftAsRightClick, "(OSX) Set to True when the current click was a ctrl-click that spawned a simulated right click")
        .def_prop_ro("mouse_down_duration",
            [](ImGuiIO &self) -> nb::ndarray<float, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownDuration;
            },
            "Duration the mouse button has been down (0.0 == just clicked)")
        .def_prop_ro("mouse_down_duration_prev",
            [](ImGuiIO &self) -> nb::ndarray<float, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDownDurationPrev;
            },
            "Previous time the mouse button has been down")
        .def_prop_ro("mouse_drag_max_distance_sqr",
            [](ImGuiIO &self) -> nb::ndarray<float, nb::numpy, nb::shape<5>, nb::c_contig>
            {
                return self.MouseDragMaxDistanceSqr;
            },
            "Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)")
        .def_rw("pen_pressure", &ImGuiIO::PenPressure, "Touch/Pen pressure (0.0 to 1.0, should be >0.0 only when MouseDown[0] == True). Helper storage currently unused by Dear ImGui.")
        .def_rw("app_focus_lost", &ImGuiIO::AppFocusLost, "Only modify via AddFocusEvent()")
        .def_rw("app_accepting_events", &ImGuiIO::AppAcceptingEvents, "Only modify via SetAppAcceptingEvents()")
        .def_rw("backend_using_legacy_key_arrays", &ImGuiIO::BackendUsingLegacyKeyArrays, "-1: unknown, 0: using AddKeyEvent(), 1: using legacy io.KeysDown[]")
        .def_rw("backend_using_legacy_nav_input_array", &ImGuiIO::BackendUsingLegacyNavInputArray, "0: using AddKeyAnalogEvent(), 1: writing to legacy io.NavInputs[] directly")
        .def_rw("input_queue_surrogate", &ImGuiIO::InputQueueSurrogate, "For AddInputCharacterUTF16()")
        .def_rw("input_queue_characters", &ImGuiIO::InputQueueCharacters, "")
        .def(nb::init<>())
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("set_ini_filename",
            &ImGuiIO::SetIniFilename, nb::arg("filename"))
        .def("set_log_filename",
            &ImGuiIO::SetLogFilename, nb::arg("filename"))
        .def("get_ini_filename",
            &ImGuiIO::GetIniFilename)
        .def("get_log_filename",
            &ImGuiIO::GetLogFilename)
        // #endif
        //
        ;


    auto pyClassImGuiInputTextCallbackData =
        nb::class_<ImGuiInputTextCallbackData>
            (m, "InputTextCallbackData", " Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.\n The callback function should return 0 by default.\n Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)\n - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns True on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)\n - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration\n - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB\n - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows\n - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.\n - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.")
        .def_rw("ctx", &ImGuiInputTextCallbackData::Ctx, "Parent UI context")
        .def_rw("event_flag", &ImGuiInputTextCallbackData::EventFlag, "One ImGuiInputTextFlags_Callback*    // Read-only")
        .def_rw("flags", &ImGuiInputTextCallbackData::Flags, "What user passed to InputText()      // Read-only")
        .def_rw("user_data", &ImGuiInputTextCallbackData::UserData, "What user passed to InputText()      // Read-only")
        .def_rw("event_char", &ImGuiInputTextCallbackData::EventChar, "Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;")
        .def_rw("event_key", &ImGuiInputTextCallbackData::EventKey, "Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]")
        .def_ro("buf", &ImGuiInputTextCallbackData::Buf, "Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!")
        .def_rw("buf_text_len", &ImGuiInputTextCallbackData::BufTextLen, "Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()")
        .def_rw("buf_size", &ImGuiInputTextCallbackData::BufSize, "Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1")
        .def_rw("buf_dirty", &ImGuiInputTextCallbackData::BufDirty, "Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]")
        .def_rw("cursor_pos", &ImGuiInputTextCallbackData::CursorPos, "// Read-write   // [Completion,History,Always]")
        .def_rw("selection_start", &ImGuiInputTextCallbackData::SelectionStart, "// Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)")
        .def_rw("selection_end", &ImGuiInputTextCallbackData::SelectionEnd, "// Read-write   // [Completion,History,Always]")
        .def(nb::init<>())
        .def("delete_chars",
            &ImGuiInputTextCallbackData::DeleteChars, nb::arg("pos"), nb::arg("bytes_count"))
        .def("insert_chars",
            [](ImGuiInputTextCallbackData & self, int pos, const char * text, std::optional<std::string> text_end = std::nullopt)
            {
                auto InsertChars_adapt_const_char_pointer_with_default_null = [&self](int pos, const char * text, std::optional<std::string> text_end = std::nullopt)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.InsertChars(pos, text, text_end_adapt_default_null);
                };

                InsertChars_adapt_const_char_pointer_with_default_null(pos, text, text_end);
            },     nb::arg("pos"), nb::arg("text"), nb::arg("text_end") = nb::none())
        .def("select_all",
            &ImGuiInputTextCallbackData::SelectAll, "(private API)")
        .def("clear_selection",
            &ImGuiInputTextCallbackData::ClearSelection, "(private API)")
        .def("has_selection",
            &ImGuiInputTextCallbackData::HasSelection, "(private API)")
        ;


    auto pyClassImGuiSizeCallbackData =
        nb::class_<ImGuiSizeCallbackData>
            (m, "SizeCallbackData", " Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().\n NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.")
        .def("__init__", [](ImGuiSizeCallbackData * self, const std::optional<const ImVec2> & Pos = std::nullopt, const std::optional<const ImVec2> & CurrentSize = std::nullopt, const std::optional<const ImVec2> & DesiredSize = std::nullopt)
        {
            new (self) ImGuiSizeCallbackData();  // placement new
            auto r = self;
            if (Pos.has_value())
                r->Pos = Pos.value();
            else
                r->Pos = ImVec2();
            if (CurrentSize.has_value())
                r->CurrentSize = CurrentSize.value();
            else
                r->CurrentSize = ImVec2();
            if (DesiredSize.has_value())
                r->DesiredSize = DesiredSize.value();
            else
                r->DesiredSize = ImVec2();
        },
        nb::arg("pos") = nb::none(), nb::arg("current_size") = nb::none(), nb::arg("desired_size") = nb::none()
        )
        .def_rw("user_data", &ImGuiSizeCallbackData::UserData, "Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).")
        .def_rw("pos", &ImGuiSizeCallbackData::Pos, "Read-only.   Window position, for reference.")
        .def_rw("current_size", &ImGuiSizeCallbackData::CurrentSize, "Read-only.   Current window size.")
        .def_rw("desired_size", &ImGuiSizeCallbackData::DesiredSize, "Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.")
        ;


    auto pyClassImGuiWindowClass =
        nb::class_<ImGuiWindowClass>
            (m, "WindowClass", " [ALPHA] Rarely used / very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.\n Important: the content of this class is still highly WIP and likely to change and be refactored\n before we stabilize Docking features. Please be mindful if using this.\n Provide hints:\n - To the platform backend via altered viewport flags (enable/disable OS decoration, OS task bar icons, etc.)\n - To the platform backend for OS level parent/child relationships of viewport.\n - To the docking system for various options and filtering.")
        .def_rw("class_id", &ImGuiWindowClass::ClassId, "User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.")
        .def_rw("parent_viewport_id", &ImGuiWindowClass::ParentViewportId, "Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent<>child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.")
        .def_rw("focus_route_parent_window_id", &ImGuiWindowClass::FocusRouteParentWindowId, "ID of parent window for shortcut focus route evaluation, e.g. Shortcut() call from Parent Window will succeed when this window is focused.")
        .def_rw("viewport_flags_override_set", &ImGuiWindowClass::ViewportFlagsOverrideSet, "Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.")
        .def_rw("viewport_flags_override_clear", &ImGuiWindowClass::ViewportFlagsOverrideClear, "Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.")
        .def_rw("tab_item_flags_override_set", &ImGuiWindowClass::TabItemFlagsOverrideSet, "[EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.")
        .def_rw("dock_node_flags_override_set", &ImGuiWindowClass::DockNodeFlagsOverrideSet, "[EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)")
        .def_rw("docking_always_tab_bar", &ImGuiWindowClass::DockingAlwaysTabBar, "Set to True to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)")
        .def_rw("docking_allow_unclassed", &ImGuiWindowClass::DockingAllowUnclassed, "Set to True to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?")
        .def(nb::init<>())
        ;


    auto pyClassImGuiPayload =
        nb::class_<ImGuiPayload>
            (m, "Payload", "Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()")
        .def_rw("data", &ImGuiPayload::Data, "Data (copied and owned by dear imgui)")
        .def_rw("data_size", &ImGuiPayload::DataSize, "Data size")
        .def_rw("source_id", &ImGuiPayload::SourceId, "Source item id")
        .def_rw("source_parent_id", &ImGuiPayload::SourceParentId, "Source parent id (if available)")
        .def_rw("data_frame_count", &ImGuiPayload::DataFrameCount, "Data timestamp")
        .def_rw("preview", &ImGuiPayload::Preview, "Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)")
        .def_rw("delivery", &ImGuiPayload::Delivery, "Set when AcceptDragDropPayload() was called and mouse button is released over the target item.")
        .def(nb::init<>())
        .def("clear",
            &ImGuiPayload::Clear, "(private API)")
        .def("is_data_type",
            &ImGuiPayload::IsDataType,
            nb::arg("type"),
            "(private API)")
        .def("is_preview",
            &ImGuiPayload::IsPreview, "(private API)")
        .def("is_delivery",
            &ImGuiPayload::IsDelivery, "(private API)")
        ;


    auto pyClassImGuiOnceUponAFrame =
        nb::class_<ImGuiOnceUponAFrame>
            (m, "OnceUponAFrame", " Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.\n Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text(\"This will be called only once per frame\");")
        .def(nb::init<>())
        .def_rw("ref_frame", &ImGuiOnceUponAFrame::RefFrame, "")
        .def("__bool__",
            &ImGuiOnceUponAFrame::operator bool)
        ;


    auto pyClassImGuiTextFilter =
        nb::class_<ImGuiTextFilter>
            (m, "TextFilter", "Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"");

    { // inner classes & enums of TextFilter
        auto pyClassImGuiTextFilter_ClassImGuiTextRange =
            nb::class_<ImGuiTextFilter::ImGuiTextRange>
                (pyClassImGuiTextFilter, "TextRange", "[Internal]")
            .def_ro("b", &ImGuiTextFilter::ImGuiTextRange::b, "")
            .def_ro("e", &ImGuiTextFilter::ImGuiTextRange::e, "")
            .def(nb::init<>())
            .def(nb::init<const char *, const char *>(),
                nb::arg("_b"), nb::arg("_e"))
            .def("empty",
                &ImGuiTextFilter::ImGuiTextRange::empty, "(private API)")
            ;
    } // end of inner classes & enums of TextFilter

    pyClassImGuiTextFilter
        .def(nb::init<const char *>(),
            nb::arg("default_filter") = "")
        .def("draw",
            &ImGuiTextFilter::Draw,
            nb::arg("label") = "Filter (inc,-exc)", nb::arg("width") = 0.0f,
            "Helper calling InputText+Build")
        .def("pass_filter",
            [](const ImGuiTextFilter & self, const char * text, std::optional<std::string> text_end = std::nullopt) -> bool
            {
                auto PassFilter_adapt_const_char_pointer_with_default_null = [&self](const char * text, std::optional<std::string> text_end = std::nullopt) -> bool
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    auto lambda_result = self.PassFilter(text, text_end_adapt_default_null);
                    return lambda_result;
                };

                return PassFilter_adapt_const_char_pointer_with_default_null(text, text_end);
            },     nb::arg("text"), nb::arg("text_end") = nb::none())
        .def("build",
            &ImGuiTextFilter::Build)
        .def("clear",
            &ImGuiTextFilter::Clear, "(private API)")
        .def("is_active",
            &ImGuiTextFilter::IsActive, "(private API)")
        .def_rw("count_grep", &ImGuiTextFilter::CountGrep, "")
        ;


    auto pyClassImGuiTextBuffer =
        nb::class_<ImGuiTextBuffer>
            (m, "TextBuffer", " Helper: Growable text buffer for logging/accumulating text\n (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')")
        .def_rw("buf", &ImGuiTextBuffer::Buf, "")
        .def(nb::init<>())
        .def("__getitem__",
            &ImGuiTextBuffer::operator[],
            nb::arg("i"),
            "(private API)")
        .def("begin",
            &ImGuiTextBuffer::begin,
            "(private API)",
            nb::rv_policy::reference)
        .def("end",
            &ImGuiTextBuffer::end,
            "(private API)\n\n Buf is zero-terminated, so end() will point on the zero-terminator",
            nb::rv_policy::reference)
        .def("size",
            &ImGuiTextBuffer::size, "(private API)")
        .def("empty",
            &ImGuiTextBuffer::empty, "(private API)")
        .def("clear",
            &ImGuiTextBuffer::clear, "(private API)")
        .def("reserve",
            &ImGuiTextBuffer::reserve,
            nb::arg("capacity"),
            "(private API)")
        .def("c_str",
            &ImGuiTextBuffer::c_str,
            "(private API)",
            nb::rv_policy::reference)
        .def("append",
            [](ImGuiTextBuffer & self, const char * str, std::optional<std::string> str_end = std::nullopt)
            {
                auto append_adapt_const_char_pointer_with_default_null = [&self](const char * str, std::optional<std::string> str_end = std::nullopt)
                {
                    const char * str_end_adapt_default_null = nullptr;
                    if (str_end.has_value())
                        str_end_adapt_default_null = str_end.value().c_str();

                    self.append(str, str_end_adapt_default_null);
                };

                append_adapt_const_char_pointer_with_default_null(str, str_end);
            },     nb::arg("str"), nb::arg("str_end") = nb::none())
        .def("appendf",
            [](ImGuiTextBuffer & self, const char * fmt)
            {
                auto appendf_adapt_variadic_format = [&self](const char * fmt)
                {
                    self.appendf("%s", fmt);
                };

                appendf_adapt_variadic_format(fmt);
            },     nb::arg("fmt"))
        ;


    auto pyClassImGuiStoragePair =
        nb::class_<ImGuiStoragePair>
            (m, "StoragePair", "[Internal] Key+Value for ImGuiStorage")
        .def_rw("key", &ImGuiStoragePair::key, "")
        .def(nb::init<ImGuiID, int>(),
            nb::arg("_key"), nb::arg("_val"))
        .def(nb::init<ImGuiID, float>(),
            nb::arg("_key"), nb::arg("_val"))
        .def(nb::init<ImGuiID, void *>(),
            nb::arg("_key"), nb::arg("_val"))
        ;


    auto pyClassImGuiStorage =
        nb::class_<ImGuiStorage>
            (m, "Storage", " Helper: Key->Value storage\n Typically you don't have to worry about this since a storage is held within each Window.\n We use it to e.g. store collapse state for a tree (Int 0/1)\n This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)\n You can use it as custom user storage for temporary values. Declare your own storage if, for example:\n - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).\n - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)\n Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.")
        .def(nb::init<>()) // implicit default constructor
        .def("clear",
            &ImGuiStorage::Clear, " - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)\n - Set***() functions find pair, insertion on demand if missing.\n - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.\n(private API)")
        .def("get_int",
            &ImGuiStorage::GetInt, nb::arg("key"), nb::arg("default_val") = 0)
        .def("set_int",
            &ImGuiStorage::SetInt, nb::arg("key"), nb::arg("val"))
        .def("get_bool",
            &ImGuiStorage::GetBool, nb::arg("key"), nb::arg("default_val") = false)
        .def("set_bool",
            &ImGuiStorage::SetBool, nb::arg("key"), nb::arg("val"))
        .def("get_float",
            &ImGuiStorage::GetFloat, nb::arg("key"), nb::arg("default_val") = 0.0f)
        .def("set_float",
            &ImGuiStorage::SetFloat, nb::arg("key"), nb::arg("val"))
        .def("get_void_ptr",
            &ImGuiStorage::GetVoidPtr,
            nb::arg("key"),
            "default_val is None",
            nb::rv_policy::reference)
        .def("set_void_ptr",
            &ImGuiStorage::SetVoidPtr, nb::arg("key"), nb::arg("val"))
        .def("get_int_ref",
            &ImGuiStorage::GetIntRef,
            nb::arg("key"), nb::arg("default_val") = 0,
            nb::rv_policy::reference)
        .def("get_bool_ref",
            &ImGuiStorage::GetBoolRef,
            nb::arg("key"), nb::arg("default_val") = false,
            nb::rv_policy::reference)
        .def("get_float_ref",
            &ImGuiStorage::GetFloatRef,
            nb::arg("key"), nb::arg("default_val") = 0.0f,
            nb::rv_policy::reference)
        .def("build_sort_by_key",
            &ImGuiStorage::BuildSortByKey, "Advanced: for quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.")
        .def("set_all_int",
            &ImGuiStorage::SetAllInt,
            nb::arg("val"),
            "Obsolete: use on your own storage if you know only integer are being stored (open/close all tree nodes)")
        ;


    auto pyClassImGuiListClipper =
        nb::class_<ImGuiListClipper>
            (m, "ListClipper", " Helper: Manually clip large list of items.\n If you have lots evenly spaced items and you have random access to the list, you can perform coarse\n clipping based on visibility to only submit items that are in view.\n The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.\n (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally\n  fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily\n  scale using lists with tens of thousands of items without a problem)\n Usage:\n   ImGuiListClipper clipper;\n   clipper.Begin(1000);         // We have 1000 elements, evenly spaced.\n   while (clipper.Step())\n       for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n           ImGui::Text(\"line number %d\", i);\n Generally what happens is:\n - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.\n - User code submit that one element.\n - Clipper can measure the height of the first element\n - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.\n - User code submit visible elements.\n - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.")
        .def_rw("ctx", &ImGuiListClipper::Ctx, "Parent UI context")
        .def_rw("display_start", &ImGuiListClipper::DisplayStart, "First item to display, updated by each call to Step()")
        .def_rw("display_end", &ImGuiListClipper::DisplayEnd, "End of items to display (exclusive)")
        .def_rw("items_count", &ImGuiListClipper::ItemsCount, "[Internal] Number of items")
        .def_rw("items_height", &ImGuiListClipper::ItemsHeight, "[Internal] Height of item after a first step and item submission can calculate it")
        .def_rw("start_pos_y", &ImGuiListClipper::StartPosY, "[Internal] Cursor position at the time of Begin() or after table frozen rows are all processed")
        .def_rw("start_seek_offset_y", &ImGuiListClipper::StartSeekOffsetY, "[Internal] Account for frozen rows in a table and initial loss of precision in very large windows.")
        .def_rw("temp_data", &ImGuiListClipper::TempData, "[Internal] Internal data")
        .def(nb::init<>(),
            " items_count: Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step, and you can call SeekCursorForItem() manually if you need)\n items_height: Use -1.0 to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().")
        .def("begin",
            &ImGuiListClipper::Begin, nb::arg("items_count"), nb::arg("items_height") = -1.0f)
        .def("end",
            &ImGuiListClipper::End, "Automatically called on the last call of Step() that returns False.")
        .def("step",
            &ImGuiListClipper::Step, "Call until it returns False. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.")
        .def("include_item_by_index",
            &ImGuiListClipper::IncludeItemByIndex,
            nb::arg("item_index"),
            " Call IncludeItemByIndex() or IncludeItemsByIndex() *BEFORE* first call to Step() if you need a range of items to not be clipped, regardless of their visibility.\n (Due to alignment / padding of certain items it is possible that an extra item may be included on either end of the display range).\n(private API)")
        .def("include_items_by_index",
            &ImGuiListClipper::IncludeItemsByIndex,
            nb::arg("item_begin"), nb::arg("item_end"),
            "item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.")
        .def("seek_cursor_for_item",
            &ImGuiListClipper::SeekCursorForItem,
            nb::arg("item_index"),
            " Seek cursor toward given item. This is automatically called while stepping.\n - The only reason to call this is: you can use ImGuiListClipper::Begin(INT_MAX) if you don't know item count ahead of time.\n - In this case, after all steps are done, you'll want to call SeekCursorForItem(item_count).")
        ;


    auto pyClassImColor =
        nb::class_<ImColor>
            (m, "ImColor", " Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)\n Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.\n **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.\n **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.")
        .def_rw("value", &ImColor::Value, "")
        .def(nb::init<>())
        .def(nb::init<float, float, float, float>(),
            nb::arg("r"), nb::arg("g"), nb::arg("b"), nb::arg("a") = 1.0f)
        .def(nb::init<const ImVec4 &>(),
            nb::arg("col"))
        .def(nb::init<int, int, int, int>(),
            nb::arg("r"), nb::arg("g"), nb::arg("b"), nb::arg("a") = 255)
        .def(nb::init<ImU32>(),
            nb::arg("rgba"))
        .def("set_hsv",
            &ImColor::SetHSV,
            nb::arg("h"), nb::arg("s"), nb::arg("v"), nb::arg("a") = 1.0f,
            "(private API)")
        .def_static("hsv",
            &ImColor::HSV,
            nb::arg("h"), nb::arg("s"), nb::arg("v"), nb::arg("a") = 1.0f,
            "(private API)")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("to_dict",
            &ImColor::to_dict, "(private API)")
        .def_static("from_dict",
            &ImColor::from_dict,
            nb::arg("d"),
            "(private API)")
        // #endif
        //
        .def("__copy__",  [](const ImColor &self) {
            return ImColor(self);
        })    ;


    auto pyEnumMultiSelectFlags_ =
        nb::enum_<ImGuiMultiSelectFlags_>(m, "MultiSelectFlags_", nb::is_arithmetic(), "Flags for BeginMultiSelect()")
            .value("none", ImGuiMultiSelectFlags_None, "")
            .value("single_select", ImGuiMultiSelectFlags_SingleSelect, "Disable selecting more than one item. This is available to allow single-selection code to share same code/logic if desired. It essentially disables the main purpose of BeginMultiSelect() tho!")
            .value("no_select_all", ImGuiMultiSelectFlags_NoSelectAll, "Disable CTRL+A shortcut to select all.")
            .value("no_range_select", ImGuiMultiSelectFlags_NoRangeSelect, "Disable Shift+selection mouse/keyboard support (useful for unordered 2D selection). With BoxSelect is also ensure contiguous SetRange requests are not combined into one. This allows not handling interpolation in SetRange requests.")
            .value("no_auto_select", ImGuiMultiSelectFlags_NoAutoSelect, "Disable selecting items when navigating (useful for e.g. supporting range-select in a list of checkboxes).")
            .value("no_auto_clear", ImGuiMultiSelectFlags_NoAutoClear, "Disable clearing selection when navigating or selecting another one (generally used with ImGuiMultiSelectFlags_NoAutoSelect. useful for e.g. supporting range-select in a list of checkboxes).")
            .value("no_auto_clear_on_reselect", ImGuiMultiSelectFlags_NoAutoClearOnReselect, "Disable clearing selection when clicking/selecting an already selected item.")
            .value("box_select1d", ImGuiMultiSelectFlags_BoxSelect1d, "Enable box-selection with same width and same x pos items (e.g. full row Selectable()). Box-selection works better with little bit of spacing between items hit-box in order to be able to aim at empty space.")
            .value("box_select2d", ImGuiMultiSelectFlags_BoxSelect2d, "Enable box-selection with varying width or varying x pos items support (e.g. different width labels, or 2D layout/grid). This is slower: alters clipping logic so that e.g. horizontal movements will update selection of normally clipped items.")
            .value("box_select_no_scroll", ImGuiMultiSelectFlags_BoxSelectNoScroll, "Disable scrolling when box-selecting near edges of scope.")
            .value("clear_on_escape", ImGuiMultiSelectFlags_ClearOnEscape, "Clear selection when pressing Escape while scope is focused.")
            .value("clear_on_click_void", ImGuiMultiSelectFlags_ClearOnClickVoid, "Clear selection when clicking on empty location within scope.")
            .value("scope_window", ImGuiMultiSelectFlags_ScopeWindow, "Scope for _BoxSelect and _ClearOnClickVoid is whole window (Default). Use if BeginMultiSelect() covers a whole window or used a single time in same window.")
            .value("scope_rect", ImGuiMultiSelectFlags_ScopeRect, "Scope for _BoxSelect and _ClearOnClickVoid is rectangle encompassing BeginMultiSelect()/EndMultiSelect(). Use if BeginMultiSelect() is called multiple times in same window.")
            .value("select_on_click", ImGuiMultiSelectFlags_SelectOnClick, "Apply selection on mouse down when clicking on unselected item. (Default)")
            .value("select_on_click_release", ImGuiMultiSelectFlags_SelectOnClickRelease, "Apply selection on mouse release when clicking an unselected item. Allow dragging an unselected item without altering selection.")
            .value("nav_wrap_x", ImGuiMultiSelectFlags_NavWrapX, "[Temporary] Enable navigation wrapping on X axis. Provided as a convenience because we don't have a design for the general Nav API for this yet. When the more general feature be public we may obsolete this flag in favor of new one.");


    auto pyClassImGuiMultiSelectIO =
        nb::class_<ImGuiMultiSelectIO>
            (m, "MultiSelectIO", " Main IO structure returned by BeginMultiSelect()/EndMultiSelect().\n This mainly contains a list of selection requests.\n - Use 'Demo->Tools->Debug Log->Selection' to see requests as they happen.\n - Some fields are only useful if your list is dynamic and allows deletion (getting post-deletion focus/state right is shown in the demo)\n - Below: who reads/writes each fields? 'r'=read, 'w'=write, 'ms'=multi-select code, 'app'=application/user code.")
        .def("__init__", [](ImGuiMultiSelectIO * self, const std::optional<const ImVector<ImGuiSelectionRequest>> & Requests = std::nullopt, const std::optional<const ImGuiSelectionUserData> & RangeSrcItem = std::nullopt, const std::optional<const ImGuiSelectionUserData> & NavIdItem = std::nullopt, bool NavIdSelected = bool(), bool RangeSrcReset = bool(), int ItemsCount = int())
        {
            new (self) ImGuiMultiSelectIO();  // placement new
            auto r = self;
            if (Requests.has_value())
                r->Requests = Requests.value();
            else
                r->Requests = ImVector<ImGuiSelectionRequest>();
            if (RangeSrcItem.has_value())
                r->RangeSrcItem = RangeSrcItem.value();
            else
                r->RangeSrcItem = ImGuiSelectionUserData();
            if (NavIdItem.has_value())
                r->NavIdItem = NavIdItem.value();
            else
                r->NavIdItem = ImGuiSelectionUserData();
            r->NavIdSelected = NavIdSelected;
            r->RangeSrcReset = RangeSrcReset;
            r->ItemsCount = ItemsCount;
        },
        nb::arg("requests") = nb::none(), nb::arg("range_src_item") = nb::none(), nb::arg("nav_id_item") = nb::none(), nb::arg("nav_id_selected") = bool(), nb::arg("range_src_reset") = bool(), nb::arg("items_count") = int()
        )
        .def_rw("requests", &ImGuiMultiSelectIO::Requests, "ms:w, app:r     /  ms:w  app:r   // Requests to apply to your selection data.")
        .def_rw("range_src_item", &ImGuiMultiSelectIO::RangeSrcItem, "ms:w  app:r     /                // (If using clipper) Begin: Source item (often the first selected item) must never be clipped: use clipper.IncludeItemByIndex() to ensure it is submitted.")
        .def_rw("nav_id_item", &ImGuiMultiSelectIO::NavIdItem, "ms:w, app:r     /                // (If using deletion) Last known SetNextItemSelectionUserData() value for NavId (if part of submitted items).")
        .def_rw("nav_id_selected", &ImGuiMultiSelectIO::NavIdSelected, "ms:w, app:r     /        app:r   // (If using deletion) Last known selection state for NavId (if part of submitted items).")
        .def_rw("range_src_reset", &ImGuiMultiSelectIO::RangeSrcReset, "app:w     /  ms:r          // (If using deletion) Set before EndMultiSelect() to reset ResetSrcItem (e.g. if deleted selection).")
        .def_rw("items_count", &ImGuiMultiSelectIO::ItemsCount, "ms:w, app:r     /        app:r   // 'int items_count' parameter to BeginMultiSelect() is copied here for convenience, allowing simpler calls to your ApplyRequests handler. Not used internally.")
        ;


    auto pyEnumSelectionRequestType =
        nb::enum_<ImGuiSelectionRequestType>(m, "SelectionRequestType", nb::is_arithmetic(), "Selection request type")
            .value("none", ImGuiSelectionRequestType_None, "")
            .value("set_all", ImGuiSelectionRequestType_SetAll, "Request app to clear selection (if Selected==False) or select all items (if Selected==True). We cannot set RangeFirstItem/RangeLastItem as its contents is entirely up to user (not necessarily an index)")
            .value("set_range", ImGuiSelectionRequestType_SetRange, "Request app to select/unselect [RangeFirstItem..RangeLastItem] items (inclusive) based on value of Selected. Only EndMultiSelect() request this, app code can read after BeginMultiSelect() and it will always be False.");


    auto pyClassImGuiSelectionRequest =
        nb::class_<ImGuiSelectionRequest>
            (m, "SelectionRequest", "Selection request item")
        .def("__init__", [](ImGuiSelectionRequest * self, ImGuiSelectionRequestType Type = ImGuiSelectionRequestType(), bool Selected = bool(), ImS8 RangeDirection = ImS8(), const std::optional<const ImGuiSelectionUserData> & RangeFirstItem = std::nullopt, const std::optional<const ImGuiSelectionUserData> & RangeLastItem = std::nullopt)
        {
            new (self) ImGuiSelectionRequest();  // placement new
            auto r = self;
            r->Type = Type;
            r->Selected = Selected;
            r->RangeDirection = RangeDirection;
            if (RangeFirstItem.has_value())
                r->RangeFirstItem = RangeFirstItem.value();
            else
                r->RangeFirstItem = ImGuiSelectionUserData();
            if (RangeLastItem.has_value())
                r->RangeLastItem = RangeLastItem.value();
            else
                r->RangeLastItem = ImGuiSelectionUserData();
        },
        nb::arg("type") = ImGuiSelectionRequestType(), nb::arg("selected") = bool(), nb::arg("range_direction") = ImS8(), nb::arg("range_first_item") = nb::none(), nb::arg("range_last_item") = nb::none()
        )
        .def_rw("type", &ImGuiSelectionRequest::Type, "ms:w, app:r     /  ms:w, app:r   // Request type. You'll most often receive 1 Clear + 1 SetRange with a single-item range.")
        .def_rw("selected", &ImGuiSelectionRequest::Selected, "ms:w, app:r     /  ms:w, app:r   // Parameter for SetAll/SetRange requests (True = select, False = unselect)")
        .def_rw("range_direction", &ImGuiSelectionRequest::RangeDirection, "/  ms:w  app:r   // Parameter for SetRange request: +1 when RangeFirstItem comes before RangeLastItem, -1 otherwise. Useful if you want to preserve selection order on a backward Shift+Click.")
        .def_rw("range_first_item", &ImGuiSelectionRequest::RangeFirstItem, "/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from top to bottom).")
        .def_rw("range_last_item", &ImGuiSelectionRequest::RangeLastItem, "/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from bottom to top). Inclusive!")
        ;


    auto pyClassImGuiSelectionBasicStorage =
        nb::class_<ImGuiSelectionBasicStorage>
            (m, "SelectionBasicStorage", " Optional helper to store multi-selection state + apply multi-selection requests.\n - Used by our demos and provided as a convenience to easily implement basic multi-selection.\n - Iterate selection with 'None* it = None; ImGuiID id; while (selection.GetNextSelectedItem(&it, &id)) { ... }'\n   Or you can check 'if (Contains(id)) { ... }' for each possible object if their number is not too high to iterate.\n - USING THIS IS NOT MANDATORY. This is only a helper and not a required API.\n To store a multi-selection, in your application you could:\n - Use this helper as a convenience. We use our simple key->value ImGuiStorage as a std::set<ImGuiID> replacement.\n - Use your own external storage: e.g. std::set<MyObjectId>, std::vector<MyObjectId>, interval trees, intrusively stored selection etc.\n In ImGuiSelectionBasicStorage we:\n - always use indices in the multi-selection API (passed to SetNextItemSelectionUserData(), retrieved in ImGuiMultiSelectIO)\n - use the AdapterIndexToStorageId() indirection layer to abstract how persistent selection data is derived from an index.\n - use decently optimized logic to allow queries and insertion of very large selection sets.\n - do not preserve selection order.\n Many combinations are possible depending on how you prefer to store your items and how you prefer to store your selection.\n Large applications are likely to eventually want to get rid of this indirection layer and do their own thing.\n See https://github.com/ocornut/imgui/wiki/Multi-Select for details and pseudo-code using this helper.")
        .def_rw("size", &ImGuiSelectionBasicStorage::Size, "// Number of selected items, maintained by this helper.")
        .def_rw("preserve_order", &ImGuiSelectionBasicStorage::PreserveOrder, "= False  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)")
        .def_rw("user_data", &ImGuiSelectionBasicStorage::UserData, "= None   // User data for use by adapter function        // e.g. selection.UserData = (None*)my_items;")
        .def_rw("_selection_order", &ImGuiSelectionBasicStorage::_SelectionOrder, "[Internal] Increasing counter to store selection order")
        .def_rw("_storage", &ImGuiSelectionBasicStorage::_Storage, "[Internal] Selection set. Think of this as similar to e.g. std::set<ImGuiID>. Prefer not accessing directly: iterate with GetNextSelectedItem().")
        .def(nb::init<>())
        .def("apply_requests",
            &ImGuiSelectionBasicStorage::ApplyRequests,
            nb::arg("ms_io"),
            "Apply selection requests coming from BeginMultiSelect() and EndMultiSelect() functions. It uses 'items_count' passed to BeginMultiSelect()")
        .def("contains",
            [](const ImGuiSelectionBasicStorage & self, ImGuiID id) -> bool
            {
                auto Contains_adapt_force_lambda = [&self](ImGuiID id) -> bool
                {
                    auto lambda_result = self.Contains(id);
                    return lambda_result;
                };

                return Contains_adapt_force_lambda(id);
            },
            nb::arg("id_"),
            "Query if an item id is in selection.")
        .def("clear",
            &ImGuiSelectionBasicStorage::Clear, "Clear selection")
        .def("swap",
            &ImGuiSelectionBasicStorage::Swap,
            nb::arg("r"),
            "Swap two selections")
        .def("set_item_selected",
            &ImGuiSelectionBasicStorage::SetItemSelected,
            nb::arg("id_"), nb::arg("selected"),
            "Add/remove an item from selection (generally done by ApplyRequests() function)")
        .def("get_storage_id_from_index",
            &ImGuiSelectionBasicStorage::GetStorageIdFromIndex,
            nb::arg("idx"),
            "(private API)\n\n Convert index to item id based on provided adapter.")
        ;


    auto pyClassImGuiSelectionExternalStorage =
        nb::class_<ImGuiSelectionExternalStorage>
            (m, "SelectionExternalStorage", " Optional helper to apply multi-selection requests to existing randomly accessible storage.\n Convenient if you want to quickly wire multi-select API on e.g. an array of bool or items storing their own selection state.")
        .def_rw("user_data", &ImGuiSelectionExternalStorage::UserData, "User data for use by adapter function                                // e.g. selection.UserData = (None*)my_items;")
        .def(nb::init<>())
        .def("apply_requests",
            &ImGuiSelectionExternalStorage::ApplyRequests,
            nb::arg("ms_io"),
            "Apply selection requests by using AdapterSetItemSelected() calls")
        ;


    auto pyClassImDrawCmd =
        nb::class_<ImDrawCmd>
            (m, "ImDrawCmd", " Typically, 1 command = 1 GPU draw call (unless command is a callback)\n - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,\n   this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.\n   Backends made for <1.71. will typically ignore the VtxOffset fields.\n - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).")
        .def_rw("clip_rect", &ImDrawCmd::ClipRect, "4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in \"viewport\" coordinates")
        .def_rw("texture_id", &ImDrawCmd::TextureId, "4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.")
        .def_rw("vtx_offset", &ImDrawCmd::VtxOffset, "4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.")
        .def_rw("idx_offset", &ImDrawCmd::IdxOffset, "4    // Start offset in index buffer.")
        .def_rw("elem_count", &ImDrawCmd::ElemCount, "4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].")
        .def_rw("user_callback_data", &ImDrawCmd::UserCallbackData, "4-8  // Callback user data (when UserCallback != None). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size > 0, this is pointing to a buffer where data is stored.")
        .def_rw("user_callback_data_size", &ImDrawCmd::UserCallbackDataSize, "4 // Size of callback user data when using storage, otherwise 0.")
        .def_rw("user_callback_data_offset", &ImDrawCmd::UserCallbackDataOffset, "4 // [Internal] Offset of callback user data when using storage, otherwise -1.")
        .def(nb::init<>(),
            "Also ensure our padding fields are zeroed")
        .def("get_tex_id",
            &ImDrawCmd::GetTexID, " Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)\n(private API)")
        ;
    // #ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
    //


    auto pyClassImDrawVert =
        nb::class_<ImDrawVert>
            (m, "ImDrawVert", "")
        .def("__init__", [](ImDrawVert * self, const std::optional<const ImVec2> & pos = std::nullopt, const std::optional<const ImVec2> & uv = std::nullopt, ImU32 col = ImU32())
        {
            new (self) ImDrawVert();  // placement new
            auto r = self;
            if (pos.has_value())
                r->pos = pos.value();
            else
                r->pos = ImVec2();
            if (uv.has_value())
                r->uv = uv.value();
            else
                r->uv = ImVec2();
            r->col = col;
        },
        nb::arg("pos") = nb::none(), nb::arg("uv") = nb::none(), nb::arg("col") = ImU32()
        )
        .def_rw("pos", &ImDrawVert::pos, "")
        .def_rw("uv", &ImDrawVert::uv, "")
        .def_rw("col", &ImDrawVert::col, "")
        ;
    // #else
    //
    // #endif
    //


    auto pyClassImDrawCmdHeader =
        nb::class_<ImDrawCmdHeader>
            (m, "ImDrawCmdHeader", "[Internal] For use by ImDrawList")
        .def("__init__", [](ImDrawCmdHeader * self, const std::optional<const ImVec4> & ClipRect = std::nullopt, const std::optional<const ImTextureID> & TextureId = std::nullopt)
        {
            new (self) ImDrawCmdHeader();  // placement new
            auto r = self;
            if (ClipRect.has_value())
                r->ClipRect = ClipRect.value();
            else
                r->ClipRect = ImVec4();
            if (TextureId.has_value())
                r->TextureId = TextureId.value();
            else
                r->TextureId = ImTextureID();
        },
        nb::arg("clip_rect") = nb::none(), nb::arg("texture_id") = nb::none()
        )
        .def_rw("clip_rect", &ImDrawCmdHeader::ClipRect, "")
        .def_rw("texture_id", &ImDrawCmdHeader::TextureId, "")
        .def_rw("vtx_offset", &ImDrawCmdHeader::VtxOffset, "")
        ;


    auto pyClassImDrawChannel =
        nb::class_<ImDrawChannel>
            (m, "ImDrawChannel", "[Internal] For use by ImDrawListSplitter")
        .def("__init__", [](ImDrawChannel * self, const std::optional<const ImVector<ImDrawCmd>> & _CmdBuffer = std::nullopt, const std::optional<const ImVector<ImDrawIdx>> & _IdxBuffer = std::nullopt)
        {
            new (self) ImDrawChannel();  // placement new
            auto r = self;
            if (_CmdBuffer.has_value())
                r->_CmdBuffer = _CmdBuffer.value();
            else
                r->_CmdBuffer = ImVector<ImDrawCmd>();
            if (_IdxBuffer.has_value())
                r->_IdxBuffer = _IdxBuffer.value();
            else
                r->_IdxBuffer = ImVector<ImDrawIdx>();
        },
        nb::arg("_cmd_buffer") = nb::none(), nb::arg("_idx_buffer") = nb::none()
        )
        .def_rw("_cmd_buffer", &ImDrawChannel::_CmdBuffer, "")
        .def_rw("_idx_buffer", &ImDrawChannel::_IdxBuffer, "")
        ;


    auto pyClassImDrawListSplitter =
        nb::class_<ImDrawListSplitter>
            (m, "ImDrawListSplitter", " Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.\n This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.")
        .def_rw("_current", &ImDrawListSplitter::_Current, "Current channel number (0)")
        .def_rw("_count", &ImDrawListSplitter::_Count, "Number of active channels (1+)")
        .def_rw("_channels", &ImDrawListSplitter::_Channels, "Draw channels (not resized down so _Count might be < Channels.Size)")
        .def(nb::init<>())
        .def("clear",
            &ImDrawListSplitter::Clear, "(private API)\n\n Do not clear Channels[] so our allocations are reused next frame")
        .def("clear_free_memory",
            &ImDrawListSplitter::ClearFreeMemory)
        .def("split",
            &ImDrawListSplitter::Split, nb::arg("draw_list"), nb::arg("count"))
        .def("merge",
            &ImDrawListSplitter::Merge, nb::arg("draw_list"))
        .def("set_current_channel",
            &ImDrawListSplitter::SetCurrentChannel, nb::arg("draw_list"), nb::arg("channel_idx"))
        ;


    auto pyEnumImDrawFlags_ =
        nb::enum_<ImDrawFlags_>(m, "ImDrawFlags_", nb::is_arithmetic(), " Flags for ImDrawList functions\n (Legacy: bit 0 must always correspond to ImDrawFlags_Closed to be backward compatible with old API using a bool. Bits 1..3 must be unused)")
            .value("none", ImDrawFlags_None, "")
            .value("closed", ImDrawFlags_Closed, "PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)")
            .value("round_corners_top_left", ImDrawFlags_RoundCornersTopLeft, "AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0, we default to all corners). Was 0x01.")
            .value("round_corners_top_right", ImDrawFlags_RoundCornersTopRight, "AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0, we default to all corners). Was 0x02.")
            .value("round_corners_bottom_left", ImDrawFlags_RoundCornersBottomLeft, "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0, we default to all corners). Was 0x04.")
            .value("round_corners_bottom_right", ImDrawFlags_RoundCornersBottomRight, "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0, we default to all corners). Wax 0x08.")
            .value("round_corners_none", ImDrawFlags_RoundCornersNone, "AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0). This is NOT zero, NOT an implicit flag!")
            .value("round_corners_top", ImDrawFlags_RoundCornersTop, "")
            .value("round_corners_bottom", ImDrawFlags_RoundCornersBottom, "")
            .value("round_corners_left", ImDrawFlags_RoundCornersLeft, "")
            .value("round_corners_right", ImDrawFlags_RoundCornersRight, "")
            .value("round_corners_all", ImDrawFlags_RoundCornersAll, "")
            .value("round_corners_default_", ImDrawFlags_RoundCornersDefault_, "Default to ALL corners if none of the _RoundCornersXX flags are specified.")
            .value("round_corners_mask_", ImDrawFlags_RoundCornersMask_, "");


    auto pyEnumImDrawListFlags_ =
        nb::enum_<ImDrawListFlags_>(m, "ImDrawListFlags_", nb::is_arithmetic(), " Flags for ImDrawList instance. Those are set automatically by ImGui:: functions from ImGuiIO settings, and generally not manipulated directly.\n It is however possible to temporarily alter flags between calls to ImDrawList:: functions.")
            .value("none", ImDrawListFlags_None, "")
            .value("anti_aliased_lines", ImDrawListFlags_AntiAliasedLines, "Enable anti-aliased lines/borders (*2 the number of triangles for 1.0 wide line or lines thin enough to be drawn using textures, otherwise *3 the number of triangles)")
            .value("anti_aliased_lines_use_tex", ImDrawListFlags_AntiAliasedLinesUseTex, "Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).")
            .value("anti_aliased_fill", ImDrawListFlags_AntiAliasedFill, "Enable anti-aliased edge around filled shapes (rounded rectangles, circles).")
            .value("allow_vtx_offset", ImDrawListFlags_AllowVtxOffset, "Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.");


    auto pyClassImDrawList =
        nb::class_<ImDrawList>
            (m, "ImDrawList", " Draw command list\n This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,\n all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.\n Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to\n access the current window draw list and draw custom primitives.\n You can interleave normal ImGui:: calls and adding primitives to the current draw list.\n In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).\n You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)\n Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.")
        .def_rw("cmd_buffer", &ImDrawList::CmdBuffer, "Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.")
        .def_rw("idx_buffer", &ImDrawList::IdxBuffer, "Index buffer. Each command consume ImDrawCmd::ElemCount of those")
        .def_rw("vtx_buffer", &ImDrawList::VtxBuffer, "Vertex buffer.")
        .def_rw("flags", &ImDrawList::Flags, "Flags, you may poke into these to adjust anti-aliasing settings per-primitive.")
        .def_rw("_vtx_current_idx", &ImDrawList::_VtxCurrentIdx, "[Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.")
        .def_rw("_data", &ImDrawList::_Data, "Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)")
        .def_rw("_vtx_write_ptr", &ImDrawList::_VtxWritePtr, "[Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)")
        .def_rw("_idx_write_ptr", &ImDrawList::_IdxWritePtr, "[Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)")
        .def_rw("_path", &ImDrawList::_Path, "[Internal] current path building")
        .def_rw("_cmd_header", &ImDrawList::_CmdHeader, "[Internal] template of active commands. Fields should match those of CmdBuffer.back().")
        .def_rw("_splitter", &ImDrawList::_Splitter, "[Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)")
        .def_rw("_clip_rect_stack", &ImDrawList::_ClipRectStack, "[Internal]")
        .def_rw("_texture_id_stack", &ImDrawList::_TextureIdStack, "[Internal]")
        .def_rw("_fringe_scale", &ImDrawList::_FringeScale, "[Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content")
        .def_ro("_owner_name", &ImDrawList::_OwnerName, "Pointer to owner window's name for debugging")
        .def(nb::init<ImDrawListSharedData *>(),
            nb::arg("shared_data"),
            "If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)")
        .def("push_clip_rect",
            &ImDrawList::PushClipRect,
            nb::arg("clip_rect_min"), nb::arg("clip_rect_max"), nb::arg("intersect_with_current_clip_rect") = false,
            "Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)")
        .def("push_clip_rect_full_screen",
            &ImDrawList::PushClipRectFullScreen)
        .def("pop_clip_rect",
            &ImDrawList::PopClipRect)
        .def("push_texture_id",
            &ImDrawList::PushTextureID, nb::arg("texture_id"))
        .def("pop_texture_id",
            &ImDrawList::PopTextureID)
        .def("get_clip_rect_min",
            &ImDrawList::GetClipRectMin, "(private API)")
        .def("get_clip_rect_max",
            &ImDrawList::GetClipRectMax, "(private API)")
        .def("add_line",
            &ImDrawList::AddLine, nb::arg("p1"), nb::arg("p2"), nb::arg("col"), nb::arg("thickness") = 1.0f)
        .def("add_rect",
            &ImDrawList::AddRect,
            nb::arg("p_min"), nb::arg("p_max"), nb::arg("col"), nb::arg("rounding") = 0.0f, nb::arg("flags") = 0, nb::arg("thickness") = 1.0f,
            "a: upper-left, b: lower-right (== upper-left + size)")
        .def("add_rect_filled",
            &ImDrawList::AddRectFilled,
            nb::arg("p_min"), nb::arg("p_max"), nb::arg("col"), nb::arg("rounding") = 0.0f, nb::arg("flags") = 0,
            "a: upper-left, b: lower-right (== upper-left + size)")
        .def("add_rect_filled_multi_color",
            &ImDrawList::AddRectFilledMultiColor, nb::arg("p_min"), nb::arg("p_max"), nb::arg("col_upr_left"), nb::arg("col_upr_right"), nb::arg("col_bot_right"), nb::arg("col_bot_left"))
        .def("add_quad",
            &ImDrawList::AddQuad, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("col"), nb::arg("thickness") = 1.0f)
        .def("add_quad_filled",
            &ImDrawList::AddQuadFilled, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("col"))
        .def("add_triangle",
            &ImDrawList::AddTriangle, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("col"), nb::arg("thickness") = 1.0f)
        .def("add_triangle_filled",
            &ImDrawList::AddTriangleFilled, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("col"))
        .def("add_circle",
            &ImDrawList::AddCircle, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments") = 0, nb::arg("thickness") = 1.0f)
        .def("add_circle_filled",
            &ImDrawList::AddCircleFilled, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments") = 0)
        .def("add_ngon",
            &ImDrawList::AddNgon, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments"), nb::arg("thickness") = 1.0f)
        .def("add_ngon_filled",
            &ImDrawList::AddNgonFilled, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("num_segments"))
        .def("add_ellipse",
            &ImDrawList::AddEllipse, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("rot") = 0.0f, nb::arg("num_segments") = 0, nb::arg("thickness") = 1.0f)
        .def("add_ellipse_filled",
            &ImDrawList::AddEllipseFilled, nb::arg("center"), nb::arg("radius"), nb::arg("col"), nb::arg("rot") = 0.0f, nb::arg("num_segments") = 0)
        .def("add_text",
            [](ImDrawList & self, const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt)
            {
                auto AddText_adapt_const_char_pointer_with_default_null = [&self](const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.AddText(pos, col, text_begin, text_end_adapt_default_null);
                };

                AddText_adapt_const_char_pointer_with_default_null(pos, col, text_begin, text_end);
            },     nb::arg("pos"), nb::arg("col"), nb::arg("text_begin"), nb::arg("text_end") = nb::none())
        .def("add_text",
            [](ImDrawList & self, const ImFont * font, float font_size, const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt, float wrap_width = 0.0f, const ImVec4 * cpu_fine_clip_rect = NULL)
            {
                auto AddText_adapt_const_char_pointer_with_default_null = [&self](const ImFont * font, float font_size, const ImVec2 & pos, ImU32 col, const char * text_begin, std::optional<std::string> text_end = std::nullopt, float wrap_width = 0.0f, const ImVec4 * cpu_fine_clip_rect = NULL)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.AddText(font, font_size, pos, col, text_begin, text_end_adapt_default_null, wrap_width, cpu_fine_clip_rect);
                };

                AddText_adapt_const_char_pointer_with_default_null(font, font_size, pos, col, text_begin, text_end, wrap_width, cpu_fine_clip_rect);
            },     nb::arg("font"), nb::arg("font_size"), nb::arg("pos"), nb::arg("col"), nb::arg("text_begin"), nb::arg("text_end") = nb::none(), nb::arg("wrap_width") = 0.0f, nb::arg("cpu_fine_clip_rect") = nb::none())
        .def("add_bezier_cubic",
            &ImDrawList::AddBezierCubic,
            nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("col"), nb::arg("thickness"), nb::arg("num_segments") = 0,
            "Cubic Bezier (4 control points)")
        .def("add_bezier_quadratic",
            &ImDrawList::AddBezierQuadratic, nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("col"), nb::arg("thickness"), nb::arg("num_segments") = 0)
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("add_polyline",
            nb::overload_cast<const std::vector<ImVec2> &, ImU32, ImDrawFlags, float>(&ImDrawList::AddPolyline), nb::arg("points"), nb::arg("col"), nb::arg("flags"), nb::arg("thickness"))
        .def("add_convex_poly_filled",
            nb::overload_cast<const std::vector<ImVec2> &, ImU32>(&ImDrawList::AddConvexPolyFilled), nb::arg("points"), nb::arg("col"))
        .def("add_concave_poly_filled",
            nb::overload_cast<const std::vector<ImVec2> &, ImU32>(&ImDrawList::AddConcavePolyFilled), nb::arg("points"), nb::arg("col"))
        // #endif
        //
        .def("add_image",
            [](ImDrawList & self, ImTextureID user_texture_id, const ImVec2 & p_min, const ImVec2 & p_max, const std::optional<const ImVec2> & uv_min = std::nullopt, const std::optional<const ImVec2> & uv_max = std::nullopt, ImU32 col = IM_COL32_WHITE)
            {
                auto AddImage_adapt_mutable_param_with_default_value = [&self](ImTextureID user_texture_id, const ImVec2 & p_min, const ImVec2 & p_max, const std::optional<const ImVec2> & uv_min = std::nullopt, const std::optional<const ImVec2> & uv_max = std::nullopt, ImU32 col = IM_COL32_WHITE)
                {

                    const ImVec2& uv_min_or_default = [&]() -> const ImVec2 {
                        if (uv_min.has_value())
                            return uv_min.value();
                        else
                            return ImVec2(0, 0);
                    }();

                    const ImVec2& uv_max_or_default = [&]() -> const ImVec2 {
                        if (uv_max.has_value())
                            return uv_max.value();
                        else
                            return ImVec2(1, 1);
                    }();

                    self.AddImage(user_texture_id, p_min, p_max, uv_min_or_default, uv_max_or_default, col);
                };

                AddImage_adapt_mutable_param_with_default_value(user_texture_id, p_min, p_max, uv_min, uv_max, col);
            },
            nb::arg("user_texture_id"), nb::arg("p_min"), nb::arg("p_max"), nb::arg("uv_min") = nb::none(), nb::arg("uv_max") = nb::none(), nb::arg("col") = IM_COL32_WHITE,
            "---\nPython bindings defaults:\n    If any of the params below is None, then its default value below will be used:\n        uv_min: ImVec2(0, 0)\n        uv_max: ImVec2(1, 1)")
        .def("add_image_quad",
            [](ImDrawList & self, ImTextureID user_texture_id, const ImVec2 & p1, const ImVec2 & p2, const ImVec2 & p3, const ImVec2 & p4, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec2> & uv2 = std::nullopt, const std::optional<const ImVec2> & uv3 = std::nullopt, const std::optional<const ImVec2> & uv4 = std::nullopt, ImU32 col = IM_COL32_WHITE)
            {
                auto AddImageQuad_adapt_mutable_param_with_default_value = [&self](ImTextureID user_texture_id, const ImVec2 & p1, const ImVec2 & p2, const ImVec2 & p3, const ImVec2 & p4, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec2> & uv2 = std::nullopt, const std::optional<const ImVec2> & uv3 = std::nullopt, const std::optional<const ImVec2> & uv4 = std::nullopt, ImU32 col = IM_COL32_WHITE)
                {

                    const ImVec2& uv1_or_default = [&]() -> const ImVec2 {
                        if (uv1.has_value())
                            return uv1.value();
                        else
                            return ImVec2(0, 0);
                    }();

                    const ImVec2& uv2_or_default = [&]() -> const ImVec2 {
                        if (uv2.has_value())
                            return uv2.value();
                        else
                            return ImVec2(1, 0);
                    }();

                    const ImVec2& uv3_or_default = [&]() -> const ImVec2 {
                        if (uv3.has_value())
                            return uv3.value();
                        else
                            return ImVec2(1, 1);
                    }();

                    const ImVec2& uv4_or_default = [&]() -> const ImVec2 {
                        if (uv4.has_value())
                            return uv4.value();
                        else
                            return ImVec2(0, 1);
                    }();

                    self.AddImageQuad(user_texture_id, p1, p2, p3, p4, uv1_or_default, uv2_or_default, uv3_or_default, uv4_or_default, col);
                };

                AddImageQuad_adapt_mutable_param_with_default_value(user_texture_id, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
            },
            nb::arg("user_texture_id"), nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("uv1") = nb::none(), nb::arg("uv2") = nb::none(), nb::arg("uv3") = nb::none(), nb::arg("uv4") = nb::none(), nb::arg("col") = IM_COL32_WHITE,
            "---\nPython bindings defaults:\n    If any of the params below is None, then its default value below will be used:\n        uv1: ImVec2(0, 0)\n        uv2: ImVec2(1, 0)\n        uv3: ImVec2(1, 1)\n        uv4: ImVec2(0, 1)")
        .def("add_image_rounded",
            &ImDrawList::AddImageRounded, nb::arg("user_texture_id"), nb::arg("p_min"), nb::arg("p_max"), nb::arg("uv_min"), nb::arg("uv_max"), nb::arg("col"), nb::arg("rounding"), nb::arg("flags") = 0)
        .def("path_clear",
            &ImDrawList::PathClear, "(private API)")
        .def("path_line_to",
            &ImDrawList::PathLineTo,
            nb::arg("pos"),
            "(private API)")
        .def("path_line_to_merge_duplicate",
            &ImDrawList::PathLineToMergeDuplicate,
            nb::arg("pos"),
            "(private API)")
        .def("path_fill_convex",
            &ImDrawList::PathFillConvex,
            nb::arg("col"),
            "(private API)")
        .def("path_fill_concave",
            &ImDrawList::PathFillConcave,
            nb::arg("col"),
            "(private API)")
        .def("path_stroke",
            &ImDrawList::PathStroke,
            nb::arg("col"), nb::arg("flags") = 0, nb::arg("thickness") = 1.0f,
            "(private API)")
        .def("path_arc_to",
            &ImDrawList::PathArcTo, nb::arg("center"), nb::arg("radius"), nb::arg("a_min"), nb::arg("a_max"), nb::arg("num_segments") = 0)
        .def("path_arc_to_fast",
            &ImDrawList::PathArcToFast,
            nb::arg("center"), nb::arg("radius"), nb::arg("a_min_of_12"), nb::arg("a_max_of_12"),
            "Use precomputed angles for a 12 steps circle")
        .def("path_elliptical_arc_to",
            &ImDrawList::PathEllipticalArcTo,
            nb::arg("center"), nb::arg("radius"), nb::arg("rot"), nb::arg("a_min"), nb::arg("a_max"), nb::arg("num_segments") = 0,
            "Ellipse")
        .def("path_bezier_cubic_curve_to",
            &ImDrawList::PathBezierCubicCurveTo,
            nb::arg("p2"), nb::arg("p3"), nb::arg("p4"), nb::arg("num_segments") = 0,
            "Cubic Bezier (4 control points)")
        .def("path_bezier_quadratic_curve_to",
            &ImDrawList::PathBezierQuadraticCurveTo,
            nb::arg("p2"), nb::arg("p3"), nb::arg("num_segments") = 0,
            "Quadratic Bezier (3 control points)")
        .def("path_rect",
            &ImDrawList::PathRect, nb::arg("rect_min"), nb::arg("rect_max"), nb::arg("rounding") = 0.0f, nb::arg("flags") = 0)
        .def("add_draw_cmd",
            &ImDrawList::AddDrawCmd, "This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible")
        .def("clone_output",
            &ImDrawList::CloneOutput,
            "Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.",
            nb::rv_policy::reference)
        .def("channels_split",
            &ImDrawList::ChannelsSplit,
            nb::arg("count"),
            "(private API)")
        .def("channels_merge",
            &ImDrawList::ChannelsMerge, "(private API)")
        .def("channels_set_current",
            &ImDrawList::ChannelsSetCurrent,
            nb::arg("n"),
            "(private API)")
        .def("prim_reserve",
            &ImDrawList::PrimReserve, nb::arg("idx_count"), nb::arg("vtx_count"))
        .def("prim_unreserve",
            &ImDrawList::PrimUnreserve, nb::arg("idx_count"), nb::arg("vtx_count"))
        .def("prim_rect",
            &ImDrawList::PrimRect,
            nb::arg("a"), nb::arg("b"), nb::arg("col"),
            "Axis aligned rectangle (composed of two triangles)")
        .def("prim_rect_uv",
            &ImDrawList::PrimRectUV, nb::arg("a"), nb::arg("b"), nb::arg("uv_a"), nb::arg("uv_b"), nb::arg("col"))
        .def("prim_quad_uv",
            &ImDrawList::PrimQuadUV, nb::arg("a"), nb::arg("b"), nb::arg("c"), nb::arg("d"), nb::arg("uv_a"), nb::arg("uv_b"), nb::arg("uv_c"), nb::arg("uv_d"), nb::arg("col"))
        .def("prim_write_vtx",
            &ImDrawList::PrimWriteVtx,
            nb::arg("pos"), nb::arg("uv"), nb::arg("col"),
            "(private API)")
        .def("prim_write_idx",
            &ImDrawList::PrimWriteIdx,
            nb::arg("idx"),
            "(private API)")
        .def("prim_vtx",
            &ImDrawList::PrimVtx,
            nb::arg("pos"), nb::arg("uv"), nb::arg("col"),
            "(private API)\n\n Write vertex with unique index")
        .def("_reset_for_new_frame",
            &ImDrawList::_ResetForNewFrame)
        .def("_clear_free_memory",
            &ImDrawList::_ClearFreeMemory)
        .def("_pop_unused_draw_cmd",
            &ImDrawList::_PopUnusedDrawCmd)
        .def("_try_merge_draw_cmds",
            &ImDrawList::_TryMergeDrawCmds)
        .def("_on_changed_clip_rect",
            &ImDrawList::_OnChangedClipRect)
        .def("_on_changed_texture_id",
            &ImDrawList::_OnChangedTextureID)
        .def("_on_changed_vtx_offset",
            &ImDrawList::_OnChangedVtxOffset)
        .def("_set_texture_id",
            &ImDrawList::_SetTextureID, nb::arg("texture_id"))
        .def("_calc_circle_auto_segment_count",
            &ImDrawList::_CalcCircleAutoSegmentCount, nb::arg("radius"))
        .def("_path_arc_to_fast_ex",
            &ImDrawList::_PathArcToFastEx, nb::arg("center"), nb::arg("radius"), nb::arg("a_min_sample"), nb::arg("a_max_sample"), nb::arg("a_step"))
        .def("_path_arc_to_n",
            &ImDrawList::_PathArcToN, nb::arg("center"), nb::arg("radius"), nb::arg("a_min"), nb::arg("a_max"), nb::arg("num_segments"))
        ;


    auto pyClassImDrawData =
        nb::class_<ImDrawData>
            (m, "ImDrawData", " All draw data to render a Dear ImGui frame\n (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,\n as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)")
        .def_rw("valid", &ImDrawData::Valid, "Only valid after Render() is called and before the next NewFrame() is called.")
        .def_rw("cmd_lists_count", &ImDrawData::CmdListsCount, "Number of ImDrawList* to render")
        .def_rw("total_idx_count", &ImDrawData::TotalIdxCount, "For convenience, sum of all ImDrawList's IdxBuffer.Size")
        .def_rw("total_vtx_count", &ImDrawData::TotalVtxCount, "For convenience, sum of all ImDrawList's VtxBuffer.Size")
        .def_rw("cmd_lists", &ImDrawData::CmdLists, "Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.")
        .def_rw("display_pos", &ImDrawData::DisplayPos, "Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)")
        .def_rw("display_size", &ImDrawData::DisplaySize, "Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)")
        .def_rw("framebuffer_scale", &ImDrawData::FramebufferScale, "Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.")
        .def_rw("owner_viewport", &ImDrawData::OwnerViewport, "Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).")
        .def(nb::init<>(),
            "Functions")
        .def("clear",
            &ImDrawData::Clear)
        .def("add_draw_list",
            nb::overload_cast<ImDrawList *>(&ImDrawData::AddDrawList),
            nb::arg("draw_list"),
            "Helper to add an external draw list into an existing ImDrawData.")
        .def("de_index_all_buffers",
            &ImDrawData::DeIndexAllBuffers, "Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!")
        .def("scale_clip_rects",
            &ImDrawData::ScaleClipRects,
            nb::arg("fb_scale"),
            "Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.")
        ;


    auto pyClassImFontConfig =
        nb::class_<ImFontConfig>
            (m, "ImFontConfig", "")
        .def_rw("font_data", &ImFontConfig::FontData, "// TTF/OTF data")
        .def_rw("font_data_size", &ImFontConfig::FontDataSize, "// TTF/OTF data size")
        .def_rw("font_data_owned_by_atlas", &ImFontConfig::FontDataOwnedByAtlas, "True     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).")
        .def_rw("font_no", &ImFontConfig::FontNo, "0        // Index of font within TTF/OTF file")
        .def_rw("size_pixels", &ImFontConfig::SizePixels, "// Size in pixels for rasterizer (more or less maps to the resulting font height).")
        .def_rw("oversample_h", &ImFontConfig::OversampleH, "2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.")
        .def_rw("oversample_v", &ImFontConfig::OversampleV, "1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.")
        .def_rw("pixel_snap_h", &ImFontConfig::PixelSnapH, "False    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.")
        .def_rw("glyph_extra_spacing", &ImFontConfig::GlyphExtraSpacing, "0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.")
        .def_rw("glyph_offset", &ImFontConfig::GlyphOffset, "0, 0     // Offset all glyphs from this font input.")
        .def_rw("glyph_min_advance_x", &ImFontConfig::GlyphMinAdvanceX, "0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font")
        .def_rw("glyph_max_advance_x", &ImFontConfig::GlyphMaxAdvanceX, "FLT_MAX  // Maximum AdvanceX for glyphs")
        .def_rw("merge_mode", &ImFontConfig::MergeMode, "False    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.")
        .def_rw("font_builder_flags", &ImFontConfig::FontBuilderFlags, "0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.")
        .def_rw("rasterizer_multiply", &ImFontConfig::RasterizerMultiply, "1.0     // Linearly brighten (>1.0) or darken (<1.0) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.")
        .def_rw("rasterizer_density", &ImFontConfig::RasterizerDensity, "1.0     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.")
        .def_rw("ellipsis_char", &ImFontConfig::EllipsisChar, "-1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.")
        .def_rw("dst_font", &ImFontConfig::DstFont, "")
        .def(nb::init<>())
        ;


    auto pyClassImFontGlyph =
        nb::class_<ImFontGlyph>
            (m, "ImFontGlyph", " Hold rendering data for one glyph.\n (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)")
        .def("__init__", [](ImFontGlyph * self, float AdvanceX = float(), float X0 = float(), float Y0 = float(), float X1 = float(), float Y1 = float(), float U0 = float(), float V0 = float(), float U1 = float(), float V1 = float())
        {
            new (self) ImFontGlyph();  // placement new
            auto r = self;
            r->AdvanceX = AdvanceX;
            r->X0 = X0;
            r->Y0 = Y0;
            r->X1 = X1;
            r->Y1 = Y1;
            r->U0 = U0;
            r->V0 = V0;
            r->U1 = U1;
            r->V1 = V1;
        },
        nb::arg("advance_x") = float(), nb::arg("x0") = float(), nb::arg("y0") = float(), nb::arg("x1") = float(), nb::arg("y1") = float(), nb::arg("u0") = float(), nb::arg("v0") = float(), nb::arg("u1") = float(), nb::arg("v1") = float()
        )
        .def_rw("advance_x", &ImFontGlyph::AdvanceX, "Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)")
        .def_rw("x0", &ImFontGlyph::X0, "Glyph corners")
        .def_rw("y0", &ImFontGlyph::Y0, "Glyph corners")
        .def_rw("x1", &ImFontGlyph::X1, "Glyph corners")
        .def_rw("y1", &ImFontGlyph::Y1, "Glyph corners")
        .def_rw("u0", &ImFontGlyph::U0, "")
        .def_rw("v0", &ImFontGlyph::V0, "")
        .def_rw("u1", &ImFontGlyph::U1, "")
        .def_rw("v1", &ImFontGlyph::V1, "")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("is_colored",
            &ImFontGlyph::isColored, "(private API)")
        .def("is_visible",
            &ImFontGlyph::isVisible, "(private API)")
        .def("get_codepoint",
            &ImFontGlyph::getCodepoint, "(private API)")
        // #endif
        ;


    auto pyClassImFontGlyphRangesBuilder =
        nb::class_<ImFontGlyphRangesBuilder>
            (m, "ImFontGlyphRangesBuilder", " Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().\n This is essentially a tightly packed of vector of 64k booleans = 8KB storage.")
        .def_rw("used_chars", &ImFontGlyphRangesBuilder::UsedChars, "Store 1-bit per Unicode code point (0=unused, 1=used)")
        .def(nb::init<>())
        .def("clear",
            &ImFontGlyphRangesBuilder::Clear, "(private API)")
        .def("get_bit",
            &ImFontGlyphRangesBuilder::GetBit,
            nb::arg("n"),
            "(private API)\n\n Get bit n in the array")
        .def("set_bit",
            &ImFontGlyphRangesBuilder::SetBit,
            nb::arg("n"),
            "(private API)\n\n Set bit n in the array")
        .def("add_char",
            &ImFontGlyphRangesBuilder::AddChar,
            nb::arg("c"),
            "(private API)\n\n Add character")
        .def("add_text",
            [](ImFontGlyphRangesBuilder & self, const char * text, std::optional<std::string> text_end = std::nullopt)
            {
                auto AddText_adapt_const_char_pointer_with_default_null = [&self](const char * text, std::optional<std::string> text_end = std::nullopt)
                {
                    const char * text_end_adapt_default_null = nullptr;
                    if (text_end.has_value())
                        text_end_adapt_default_null = text_end.value().c_str();

                    self.AddText(text, text_end_adapt_default_null);
                };

                AddText_adapt_const_char_pointer_with_default_null(text, text_end);
            },
            nb::arg("text"), nb::arg("text_end") = nb::none(),
            "Add string (each character of the UTF-8 string are added)")
        .def("build_ranges",
            &ImFontGlyphRangesBuilder::BuildRanges,
            nb::arg("out_ranges"),
            "Output new ranges")
        ;


    auto pyClassImFontAtlasCustomRect =
        nb::class_<ImFontAtlasCustomRect>
            (m, "ImFontAtlasCustomRect", "See ImFontAtlas::AddCustomRectXXX functions.")
        .def_rw("width", &ImFontAtlasCustomRect::Width, "Input    // Desired rectangle dimension")
        .def_rw("height", &ImFontAtlasCustomRect::Height, "Input    // Desired rectangle dimension")
        .def_rw("x", &ImFontAtlasCustomRect::X, "Output   // Packed position in Atlas")
        .def_rw("y", &ImFontAtlasCustomRect::Y, "Output   // Packed position in Atlas")
        .def_rw("glyph_id", &ImFontAtlasCustomRect::GlyphID, "Input    // For custom font glyphs only (ID < 0x110000)")
        .def_rw("glyph_advance_x", &ImFontAtlasCustomRect::GlyphAdvanceX, "Input    // For custom font glyphs only: glyph xadvance")
        .def_rw("glyph_offset", &ImFontAtlasCustomRect::GlyphOffset, "Input    // For custom font glyphs only: glyph display offset")
        .def_rw("font", &ImFontAtlasCustomRect::Font, "Input    // For custom font glyphs only: target font")
        .def(nb::init<>())
        .def("is_packed",
            &ImFontAtlasCustomRect::IsPacked, "(private API)")
        ;


    auto pyEnumImFontAtlasFlags_ =
        nb::enum_<ImFontAtlasFlags_>(m, "ImFontAtlasFlags_", nb::is_arithmetic(), "Flags for ImFontAtlas build")
            .value("none", ImFontAtlasFlags_None, "")
            .value("no_power_of_two_height", ImFontAtlasFlags_NoPowerOfTwoHeight, "Don't round the height to next power of two")
            .value("no_mouse_cursors", ImFontAtlasFlags_NoMouseCursors, "Don't build software mouse cursors into the atlas (save a little texture memory)")
            .value("no_baked_lines", ImFontAtlasFlags_NoBakedLines, "Don't build thick line textures into the atlas (save a little texture memory, allow support for point/nearest filtering). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).");


    auto pyClassImFontAtlas =
        nb::class_<ImFontAtlas>
            (m, "ImFontAtlas", " Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:\n  - One or more fonts.\n  - Custom graphics data needed to render the shapes needed by Dear ImGui.\n  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).\n It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.\n  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.\n  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.\n  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)\n  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.\n    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.\n Common pitfalls:\n - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the\n   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.\n - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.\n   You can set font_cfg->FontDataOwnedByAtlas=False to keep ownership of your data and it won't be freed,\n - Even though many functions are suffixed with \"TTF\", OTF data is supported just as well.\n - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!")
        .def(nb::init<>())
        .def("add_font",
            &ImFontAtlas::AddFont,
            nb::arg("font_cfg"),
            nb::rv_policy::reference)
        .def("add_font_default",
            &ImFontAtlas::AddFontDefault,
            nb::arg("font_cfg") = nb::none(),
            nb::rv_policy::reference)
        .def("clear_input_data",
            &ImFontAtlas::ClearInputData, "Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.")
        .def("clear_tex_data",
            &ImFontAtlas::ClearTexData, "Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.")
        .def("clear_fonts",
            &ImFontAtlas::ClearFonts, "Clear output font data (glyphs storage, UV coordinates).")
        .def("clear",
            &ImFontAtlas::Clear, "Clear all input and output.")
        .def("build",
            &ImFontAtlas::Build, "Build pixels data. This is called automatically for you by the GetTexData*** functions.")
        .def("is_built",
            &ImFontAtlas::IsBuilt, "(private API)\n\n Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...")
        .def("set_tex_id",
            &ImFontAtlas::SetTexID,
            nb::arg("id_"),
            "(private API)")
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("add_font_from_file_ttf",
            &ImFontAtlas::_AddFontFromFileTTF,
            nb::arg("filename"), nb::arg("size_pixels"), nb::arg("font_cfg") = nb::none(), nb::arg("glyph_ranges_as_int_list") = nb::none(),
            nb::rv_policy::reference)
        .def("get_glyph_ranges_default",
            &ImFontAtlas::_GetGlyphRangesDefault, "// Basic Latin, Extended Latin")
        .def("get_glyph_ranges_greek",
            &ImFontAtlas::_GetGlyphRangesGreek, "// Default + Greek and Coptic")
        .def("get_glyph_ranges_korean",
            &ImFontAtlas::_GetGlyphRangesKorean, "// Default + Korean characters")
        .def("get_glyph_ranges_japanese",
            &ImFontAtlas::_GetGlyphRangesJapanese, "// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs")
        .def("get_glyph_ranges_chinese_full",
            &ImFontAtlas::_GetGlyphRangesChineseFull, "// Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs")
        .def("get_glyph_ranges_chinese_simplified_common",
            &ImFontAtlas::_GetGlyphRangesChineseSimplifiedCommon, "// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese")
        .def("get_glyph_ranges_cyrillic",
            &ImFontAtlas::_GetGlyphRangesCyrillic, "// Default + about 400 Cyrillic characters")
        .def("get_glyph_ranges_thai",
            &ImFontAtlas::_GetGlyphRangesThai, "// Default + Thai characters")
        .def("get_glyph_ranges_vietnamese",
            &ImFontAtlas::_GetGlyphRangesVietnamese, "// Default + Vietnamese characters")
        // #endif
        //
        .def("add_custom_rect_regular",
            &ImFontAtlas::AddCustomRectRegular, nb::arg("width"), nb::arg("height"))
        .def("add_custom_rect_font_glyph",
            [](ImFontAtlas & self, ImFont * font, ImWchar id, int width, int height, float advance_x, const std::optional<const ImVec2> & offset = std::nullopt) -> int
            {
                auto AddCustomRectFontGlyph_adapt_mutable_param_with_default_value = [&self](ImFont * font, ImWchar id, int width, int height, float advance_x, const std::optional<const ImVec2> & offset = std::nullopt) -> int
                {

                    const ImVec2& offset_or_default = [&]() -> const ImVec2 {
                        if (offset.has_value())
                            return offset.value();
                        else
                            return ImVec2(0, 0);
                    }();

                    auto lambda_result = self.AddCustomRectFontGlyph(font, id, width, height, advance_x, offset_or_default);
                    return lambda_result;
                };

                return AddCustomRectFontGlyph_adapt_mutable_param_with_default_value(font, id, width, height, advance_x, offset);
            },
            nb::arg("font"), nb::arg("id_"), nb::arg("width"), nb::arg("height"), nb::arg("advance_x"), nb::arg("offset") = nb::none(),
            "---\nPython bindings defaults:\n    If offset is None, then its default value will be: ImVec2(0, 0)")
        .def("get_custom_rect_by_index",
            &ImFontAtlas::GetCustomRectByIndex,
            nb::arg("index"),
            "(private API)",
            nb::rv_policy::reference)
        .def("calc_custom_rect_uv",
            &ImFontAtlas::CalcCustomRectUV, nb::arg("rect"), nb::arg("out_uv_min"), nb::arg("out_uv_max"))
        .def("get_mouse_cursor_tex_data",
            &ImFontAtlas::GetMouseCursorTexData, nb::arg("cursor"), nb::arg("out_offset"), nb::arg("out_size"), nb::arg("out_uv_border"), nb::arg("out_uv_fill"))
        .def_rw("flags", &ImFontAtlas::Flags, "Build flags (see ImFontAtlasFlags_)")
        .def_rw("tex_id", &ImFontAtlas::TexID, "User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.")
        .def_rw("tex_desired_width", &ImFontAtlas::TexDesiredWidth, "Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.")
        .def_rw("tex_glyph_padding", &ImFontAtlas::TexGlyphPadding, "Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = False).")
        .def_rw("locked", &ImFontAtlas::Locked, "Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.")
        .def_rw("user_data", &ImFontAtlas::UserData, "Store your own atlas related user-data (if e.g. you have multiple font atlas).")
        .def_rw("tex_ready", &ImFontAtlas::TexReady, "Set when texture was built matching current font input")
        .def_rw("tex_pixels_use_colors", &ImFontAtlas::TexPixelsUseColors, "Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.")
        .def_rw("tex_width", &ImFontAtlas::TexWidth, "Texture width calculated during Build().")
        .def_rw("tex_height", &ImFontAtlas::TexHeight, "Texture height calculated during Build().")
        .def_rw("tex_uv_scale", &ImFontAtlas::TexUvScale, "= (1.0/TexWidth, 1.0/TexHeight)")
        .def_rw("tex_uv_white_pixel", &ImFontAtlas::TexUvWhitePixel, "Texture coordinates to a white pixel")
        .def_rw("fonts", &ImFontAtlas::Fonts, "Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.")
        .def_rw("custom_rects", &ImFontAtlas::CustomRects, "Rectangles for packing custom texture data into the atlas.")
        .def_rw("config_data", &ImFontAtlas::ConfigData, "Configuration data")
        .def_ro("font_builder_io", &ImFontAtlas::FontBuilderIO, "Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).")
        .def_rw("font_builder_flags", &ImFontAtlas::FontBuilderFlags, "Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.")
        .def_rw("pack_id_mouse_cursors", &ImFontAtlas::PackIdMouseCursors, "Custom texture rectangle ID for white pixel and mouse cursors")
        .def_rw("pack_id_lines", &ImFontAtlas::PackIdLines, "Custom texture rectangle ID for baked anti-aliased lines")
        ;


    auto pyClassImFont =
        nb::class_<ImFont>
            (m, "ImFont", " Font runtime data and rendering\n ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().")
        .def_rw("index_advance_x", &ImFont::IndexAdvanceX, "12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).")
        .def_rw("fallback_advance_x", &ImFont::FallbackAdvanceX, "4     // out // = FallbackGlyph->AdvanceX")
        .def_rw("font_size", &ImFont::FontSize, "4     // in  //            // Height of characters/line, set during loading (don't change after loading)")
        .def_rw("index_lookup", &ImFont::IndexLookup, "12-16 // out //            // Sparse. Index glyphs by Unicode code-point.")
        .def_rw("glyphs", &ImFont::Glyphs, "12-16 // out //            // All glyphs.")
        .def_ro("fallback_glyph", &ImFont::FallbackGlyph, "4-8   // out // = FindGlyph(FontFallbackChar)")
        .def_rw("container_atlas", &ImFont::ContainerAtlas, "4-8   // out //            // What we has been loaded into")
        .def_ro("config_data", &ImFont::ConfigData, "4-8   // in  //            // Pointer within ContainerAtlas->ConfigData")
        .def_rw("config_data_count", &ImFont::ConfigDataCount, "2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.")
        .def_rw("fallback_char", &ImFont::FallbackChar, "2     // out // = FFFD/'?' // Character used if a glyph isn't found.")
        .def_rw("ellipsis_char", &ImFont::EllipsisChar, "2     // out // = '...'/'.'// Character used for ellipsis rendering.")
        .def_rw("ellipsis_char_count", &ImFont::EllipsisCharCount, "1     // out // 1 or 3")
        .def_rw("ellipsis_width", &ImFont::EllipsisWidth, "4     // out               // Width")
        .def_rw("ellipsis_char_step", &ImFont::EllipsisCharStep, "4     // out               // Step between characters when EllipsisCount > 0")
        .def_rw("dirty_lookup_tables", &ImFont::DirtyLookupTables, "1     // out //")
        .def_rw("scale", &ImFont::Scale, "4     // in  // = 1.      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()")
        .def_rw("ascent", &ImFont::Ascent, "4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)")
        .def_rw("descent", &ImFont::Descent, "4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)")
        .def_rw("metrics_total_surface", &ImFont::MetricsTotalSurface, "4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)")
        .def(nb::init<>(),
            "Methods")
        .def("find_glyph",
            &ImFont::FindGlyph,
            nb::arg("c"),
            nb::rv_policy::reference)
        .def("find_glyph_no_fallback",
            &ImFont::FindGlyphNoFallback,
            nb::arg("c"),
            nb::rv_policy::reference)
        .def("get_char_advance",
            &ImFont::GetCharAdvance,
            nb::arg("c"),
            "(private API)")
        .def("is_loaded",
            &ImFont::IsLoaded, "(private API)")
        .def("get_debug_name",
            &ImFont::GetDebugName,
            "(private API)",
            nb::rv_policy::reference)
        .def("calc_word_wrap_position_a",
            &ImFont::CalcWordWrapPositionA,
            nb::arg("scale"), nb::arg("text"), nb::arg("text_end"), nb::arg("wrap_width"),
            nb::rv_policy::reference)
        .def("render_char",
            &ImFont::RenderChar, nb::arg("draw_list"), nb::arg("size"), nb::arg("pos"), nb::arg("col"), nb::arg("c"))
        .def("render_text",
            &ImFont::RenderText, nb::arg("draw_list"), nb::arg("size"), nb::arg("pos"), nb::arg("col"), nb::arg("clip_rect"), nb::arg("text_begin"), nb::arg("text_end"), nb::arg("wrap_width") = 0.0f, nb::arg("cpu_fine_clip") = false)
        .def("build_lookup_table",
            &ImFont::BuildLookupTable)
        .def("clear_output_data",
            &ImFont::ClearOutputData)
        .def("grow_index",
            &ImFont::GrowIndex, nb::arg("new_size"))
        .def("add_glyph",
            &ImFont::AddGlyph, nb::arg("src_cfg"), nb::arg("c"), nb::arg("x0"), nb::arg("y0"), nb::arg("x1"), nb::arg("y1"), nb::arg("u0"), nb::arg("v0"), nb::arg("u1"), nb::arg("v1"), nb::arg("advance_x"))
        .def("add_remap_char",
            &ImFont::AddRemapChar,
            nb::arg("dst"), nb::arg("src"), nb::arg("overwrite_dst") = true,
            "Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.")
        .def("set_glyph_visible",
            &ImFont::SetGlyphVisible, nb::arg("c"), nb::arg("visible"))
        .def("is_glyph_range_unused",
            &ImFont::IsGlyphRangeUnused, nb::arg("c_begin"), nb::arg("c_last"))
        ;


    auto pyEnumViewportFlags_ =
        nb::enum_<ImGuiViewportFlags_>(m, "ViewportFlags_", nb::is_arithmetic(), "Flags stored in ImGuiViewport::Flags, giving indications to the platform backends.")
            .value("none", ImGuiViewportFlags_None, "")
            .value("is_platform_window", ImGuiViewportFlags_IsPlatformWindow, "Represent a Platform Window")
            .value("is_platform_monitor", ImGuiViewportFlags_IsPlatformMonitor, "Represent a Platform Monitor (unused yet)")
            .value("owned_by_app", ImGuiViewportFlags_OwnedByApp, "Platform Window: Is created/managed by the user application? (rather than our backend)")
            .value("no_decoration", ImGuiViewportFlags_NoDecoration, "Platform Window: Disable platform decorations: title bar, borders, etc. (generally set all windows, but if ImGuiConfigFlags_ViewportsDecoration is set we only set this on popups/tooltips)")
            .value("no_task_bar_icon", ImGuiViewportFlags_NoTaskBarIcon, "Platform Window: Disable platform task bar icon (generally set on popups/tooltips, or all windows if ImGuiConfigFlags_ViewportsNoTaskBarIcon is set)")
            .value("no_focus_on_appearing", ImGuiViewportFlags_NoFocusOnAppearing, "Platform Window: Don't take focus when created.")
            .value("no_focus_on_click", ImGuiViewportFlags_NoFocusOnClick, "Platform Window: Don't take focus when clicked on.")
            .value("no_inputs", ImGuiViewportFlags_NoInputs, "Platform Window: Make mouse pass through so we can drag this window while peaking behind it.")
            .value("no_renderer_clear", ImGuiViewportFlags_NoRendererClear, "Platform Window: Renderer doesn't need to clear the framebuffer ahead (because we will fill it entirely).")
            .value("no_auto_merge", ImGuiViewportFlags_NoAutoMerge, "Platform Window: Avoid merging this window into another host window. This can only be set via ImGuiWindowClass viewport flags override (because we need to now ahead if we are going to create a viewport in the first place!).")
            .value("top_most", ImGuiViewportFlags_TopMost, "Platform Window: Display on top (for tooltips only).")
            .value("can_host_other_windows", ImGuiViewportFlags_CanHostOtherWindows, "Viewport can host multiple imgui windows (secondary viewports are associated to a single window). // FIXME: In practice there's still probably code making the assumption that this is always and only on the MainViewport. Will fix once we add support for \"no main viewport\".")
            .value("is_minimized", ImGuiViewportFlags_IsMinimized, "Platform Window: Window is minimized, can skip render. When minimized we tend to avoid using the viewport pos/size for clipping window or testing if they are contained in the viewport.")
            .value("is_focused", ImGuiViewportFlags_IsFocused, "Platform Window: Window is focused (last call to Platform_GetWindowFocus() returned True)");


    auto pyClassImGuiViewport =
        nb::class_<ImGuiViewport>
            (m, "Viewport", " - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.\n - With multi-viewport enabled, we extend this concept to have multiple active viewports.\n - In the future we will extend this concept further to also represent Platform Monitor and support a \"no main platform window\" operation mode.\n - About Main Area vs Work Area:\n   - Main Area = entire viewport.\n   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).\n   - Windows are generally trying to stay within the Work Area of their host viewport.")
        .def_rw("id_", &ImGuiViewport::ID, "Unique identifier for the viewport")
        .def_rw("flags", &ImGuiViewport::Flags, "See ImGuiViewportFlags_")
        .def_rw("pos", &ImGuiViewport::Pos, "Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)")
        .def_rw("size", &ImGuiViewport::Size, "Main Area: Size of the viewport.")
        .def_rw("work_pos", &ImGuiViewport::WorkPos, "Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)")
        .def_rw("work_size", &ImGuiViewport::WorkSize, "Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)")
        .def_rw("dpi_scale", &ImGuiViewport::DpiScale, "1.0 = 96 DPI = No extra scale.")
        .def_rw("parent_viewport_id", &ImGuiViewport::ParentViewportId, "(Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows.")
        .def_rw("draw_data", &ImGuiViewport::DrawData, "The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().")
        .def_rw("renderer_user_data", &ImGuiViewport::RendererUserData, "None* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.")
        .def_rw("platform_user_data", &ImGuiViewport::PlatformUserData, "None* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.")
        .def_rw("platform_handle", &ImGuiViewport::PlatformHandle, "None* to hold higher-level, platform window handle (e.g. HWND, GLFWWindow*, SDL_Window*), for FindViewportByPlatformHandle().")
        .def_rw("platform_handle_raw", &ImGuiViewport::PlatformHandleRaw, "None* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)")
        .def_rw("platform_window_created", &ImGuiViewport::PlatformWindowCreated, "Platform window has been created (Platform_CreateWindow() has been called). This is False during the first frame where a viewport is being created.")
        .def_rw("platform_request_move", &ImGuiViewport::PlatformRequestMove, "Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)")
        .def_rw("platform_request_resize", &ImGuiViewport::PlatformRequestResize, "Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)")
        .def_rw("platform_request_close", &ImGuiViewport::PlatformRequestClose, "Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)")
        .def(nb::init<>())
        .def("get_center",
            &ImGuiViewport::GetCenter, "(private API)")
        .def("get_work_center",
            &ImGuiViewport::GetWorkCenter, "(private API)")
        ;


    auto pyClassImGuiPlatformIO =
        nb::class_<ImGuiPlatformIO>
            (m, "PlatformIO", "Access via ImGui::GetPlatformIO()")
        .def(nb::init<>())
        .def_rw("platform_get_clipboard_text_fn", &ImGuiPlatformIO::Platform_GetClipboardTextFn, "")
        .def_rw("platform_set_clipboard_text_fn", &ImGuiPlatformIO::Platform_SetClipboardTextFn, "")
        .def_rw("platform_clipboard_user_data", &ImGuiPlatformIO::Platform_ClipboardUserData, "[/ADAPT_IMGUI_BUNDLE]")
        .def_rw("platform_open_in_shell_fn", &ImGuiPlatformIO::Platform_OpenInShellFn, " Optional: Open link/folder/file in OS Shell\n (default to use ShellExecuteA() on Windows, system() on Linux/Mac)\n [ADAPT_IMGUI_BUNDLE]\nbool        (*Platform_OpenInShellFn)(ImGuiContext* ctx, const char* path);")
        .def_rw("platform_open_in_shell_user_data", &ImGuiPlatformIO::Platform_OpenInShellUserData, "[/ADAPT_IMGUI_BUNDLE]")
        .def_rw("platform_ime_user_data", &ImGuiPlatformIO::Platform_ImeUserData, "")
        .def_rw("platform_locale_decimal_point", &ImGuiPlatformIO::Platform_LocaleDecimalPoint, "'.'")
        .def_rw("renderer_render_state", &ImGuiPlatformIO::Renderer_RenderState, "Written by some backends during ImGui_ImplXXXX_RenderDrawData() call to point backend_specific ImGui_ImplXXXX_RenderState* structure.")
        .def_rw("monitors", &ImGuiPlatformIO::Monitors, " (Optional) Monitor list\n - Updated by: app/backend. Update every frame to dynamically support changing monitor or DPI configuration.\n - Used by: dear imgui to query DPI info, clamp popups/tooltips within same monitor and not have them straddle monitors.")
        .def_rw("viewports", &ImGuiPlatformIO::Viewports, "Main viewports, followed by all secondary viewports.")
        ;


    auto pyClassImGuiPlatformMonitor =
        nb::class_<ImGuiPlatformMonitor>
            (m, "PlatformMonitor", " (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.\n We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.")
        .def_rw("main_pos", &ImGuiPlatformMonitor::MainPos, "Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)")
        .def_rw("main_size", &ImGuiPlatformMonitor::MainSize, "Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)")
        .def_rw("work_pos", &ImGuiPlatformMonitor::WorkPos, "Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.")
        .def_rw("work_size", &ImGuiPlatformMonitor::WorkSize, "Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.")
        .def_rw("dpi_scale", &ImGuiPlatformMonitor::DpiScale, "1.0 = 96 DPI")
        .def_rw("platform_handle", &ImGuiPlatformMonitor::PlatformHandle, "Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)")
        .def(nb::init<>())
        ;


    auto pyClassImGuiPlatformImeData =
        nb::class_<ImGuiPlatformImeData>
            (m, "PlatformImeData", "(Optional) Support for IME (Input Method Editor) via the platform_io.Platform_SetImeDataFn() function.")
        .def_rw("want_visible", &ImGuiPlatformImeData::WantVisible, "A widget wants the IME to be visible")
        .def_rw("input_pos", &ImGuiPlatformImeData::InputPos, "Position of the input cursor")
        .def_rw("input_line_height", &ImGuiPlatformImeData::InputLineHeight, "Line height")
        .def(nb::init<>())
        ;
    // #ifdef IMGUI_INCLUDE_IMGUI_USER_H
    //
    // #endif
    //
    // #endif
    ////////////////////    </generated_from:imgui.h>    ////////////////////


    ////////////////////    <generated_from:imgui_stacklayout.h>    ////////////////////
    // #ifndef IMGUI_DISABLE
    //


    m.def("begin_horizontal",
        [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginHorizontal_adapt_mutable_param_with_default_value = [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginHorizontal(str_id, size_or_default, align);
            };

            BeginHorizontal_adapt_mutable_param_with_default_value(str_id, size, align);
        },
        nb::arg("str_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_horizontal",
        [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginHorizontal_adapt_mutable_param_with_default_value = [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginHorizontal(ptr_id, size_or_default, align);
            };

            BeginHorizontal_adapt_mutable_param_with_default_value(ptr_id, size, align);
        },
        nb::arg("ptr_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_horizontal",
        [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
        {
            auto BeginHorizontal_adapt_mutable_param_with_default_value = [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginHorizontal(id, size_or_default, align);
            };

            BeginHorizontal_adapt_mutable_param_with_default_value(id, size, align);
        },
        nb::arg("id_"), nb::arg("size") = nb::none(), nb::arg("align") = -1,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("end_horizontal",
        ImGui::EndHorizontal);

    m.def("begin_vertical",
        [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginVertical_adapt_mutable_param_with_default_value = [](const char * str_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginVertical(str_id, size_or_default, align);
            };

            BeginVertical_adapt_mutable_param_with_default_value(str_id, size, align);
        },
        nb::arg("str_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_vertical",
        [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
        {
            auto BeginVertical_adapt_mutable_param_with_default_value = [](const void * ptr_id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1.0f)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginVertical(ptr_id, size_or_default, align);
            };

            BeginVertical_adapt_mutable_param_with_default_value(ptr_id, size, align);
        },
        nb::arg("ptr_id"), nb::arg("size") = nb::none(), nb::arg("align") = -1.0f,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("begin_vertical",
        [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
        {
            auto BeginVertical_adapt_mutable_param_with_default_value = [](int id, const std::optional<const ImVec2> & size = std::nullopt, float align = -1)
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImGui::BeginVertical(id, size_or_default, align);
            };

            BeginVertical_adapt_mutable_param_with_default_value(id, size, align);
        },
        nb::arg("id_"), nb::arg("size") = nb::none(), nb::arg("align") = -1,
        "---\nPython bindings defaults:\n    If size is None, then its default value will be: ImVec2(0, 0)");

    m.def("end_vertical",
        ImGui::EndVertical);

    m.def("spring",
        ImGui::Spring, nb::arg("weight") = 1.0f, nb::arg("spacing") = -1.0f);

    m.def("suspend_layout",
        ImGui::SuspendLayout);

    m.def("resume_layout",
        ImGui::ResumeLayout);
    // #endif
    ////////////////////    </generated_from:imgui_stacklayout.h>    ////////////////////


    ////////////////////    <generated_from:imgui_stacklayout_internal.h>    ////////////////////
    // #ifndef IMGUI_DISABLE
    //
    // #endif
    ////////////////////    </generated_from:imgui_stacklayout_internal.h>    ////////////////////


    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // ****************************************************************************************************************
    //
    //             MANUAL PATCHES BELOW
    //
    // ****************************************************************************************************************

    // FLT_MIN & FLT_MAX
    m.attr("FLT_MIN") = (float)FLT_MIN;
    m.attr("FLT_MAX") = (float)FLT_MAX;


    //
    //  Patches to ImColor
    //
    auto cast_to_imcolor = [](nb::handle obj) -> ImColor
    {
        if (len(obj) != 4)
            throw std::invalid_argument("Python tuple/list/array to imgui.ImVec2: size should be 2!");

        auto floats = nb::cast<std::vector<float>>(obj);
        if (floats.size()==3)
            return ImColor(floats[0], floats[1], floats[2]);
        else if (floats.size()==4)
            return ImColor(floats[0], floats[1], floats[2], floats[3]);
        else
            throw std::invalid_argument("python tuple/list/array to imgui.imcolor: size should be 3 or 4!");
    };

    pyClassImColor.def("__str__", [](const ImColor& self) -> std::string {
        char r[100];
        snprintf(r, 100, "ImColor(%f, %f, %f, %f)", self.Value.x, self.Value.y, self.Value.z, self.Value.w);
        return r;
    });
    pyClassImColor.def("__repr__", [](const ImColor& self) -> std::string {
        char r[100];
        snprintf(r, 100, "ImColor(%f, %f, %f, %f)", self.Value.x, self.Value.y, self.Value.z, self.Value.w);
        return r;
    });
    pyClassImColor.def("__getitem__", [](const ImColor& self, size_t idx) -> float {
        if (idx >= 4)
            throw nb::index_error();
        switch (idx)
        {
        case 0:
            return self.Value.x;
        case 1:
            return self.Value.y;
        case 2:
            return self.Value.z;
        case 3:
            return self.Value.w;
        default:
            // unreachable, but makes clang happy
            // (warning: non-void lambda does not return a value in all control paths [-Wreturn-type])
            return 0.f;
        }
    });
    pyClassImColor.def("__len__", [](const ImColor& self) -> size_t {
        return 4;
    });
    pyClassImColor.def("__iter__", [](const ImColor& self) {
            return nb::make_iterator(nb::type<ImColor>(), "iterator", &self.Value.x, &self.Value.x + 4);
        },
        nb::keep_alive<0, 1>() /* Essential: keep object alive while iterator exists */
    );

    pyClassImColor.def("__init__", [cast_to_imcolor](ImColor *self, nb::tuple t) {
        new (self) ImColor();
        *self = cast_to_imcolor(t);
    });
    pyClassImColor.def("__init__", [cast_to_imcolor](ImColor *self, nb::list l) {
        new (self) ImColor();
        *self = cast_to_imcolor(l);
    });
//    pyClassImColor.def("__init__", [](ImColor *self, nb::ndarray<> a) {
//        new (self) ImColor();
//        *self = cast_to_imcolor(a);
//    });


    nb::implicitly_convertible<nb::tuple, ImColor>();
    nb::implicitly_convertible<nb::list, ImColor>();
    //nb::implicitly_convertible<nb::array, ImColor>();
    nb::implicitly_convertible<ImVec4, ImColor>();
    nb::implicitly_convertible<ImColor, ImVec4>();
    // below two are not possible, even if sorely needed for our API, with current pybind11
    //nb::implicitly_convertible<ImU32, ImColor>();
    //nb::implicitly_convertible<ImColor, ImU32>();

    pyClassImColor.def("__init__", [](ImColor *self, ImColor imc) {
        new (self) ImColor();
        *self = ImColor(imc.Value.x, imc.Value.y, imc.Value.z, imc.Value.w);
    });


    // Pickle support
    pyClassImColor.def("__getstate__", [](const ImColor &p) {
        return nb::make_tuple(p.Value.x, p.Value.y, p.Value.z, p.Value.w);
    });
    pyClassImColor.def("__setstate__", [](ImColor &self, nb::tuple t) {
        new(&self) ImColor();
        if (t.size() != 4)
            throw std::runtime_error("ImVec4 unpickling failed");
        ImVec4 r(nb::cast<float>(t[0]), nb::cast<float>(t[1]), nb::cast<float>(t[2]), nb::cast<float>(t[3]));
        self = ImColor(r);
    });


    pyClassImColor.def("__eq__", [](const ImColor& self, const ImColor& other) -> bool {
        return self.Value.x == other.Value.x && self.Value.y == other.Value.y && self.Value.z == other.Value.z && self.Value.w == other.Value.w;
    });
    pyClassImColor.def("__ne__", [](const ImColor& self, const ImColor& other) -> bool {
        return self.Value.x != other.Value.x || self.Value.y != other.Value.y || self.Value.z != other.Value.z || self.Value.w != other.Value.w;
    });


    //
    //  Patches to ImFontAtlas
    //
    // make imgui.font_atlas_get_tex_data_as_rgba32() also accessible
    // as imgui.get_io().fonts.get_tex_data_as_rgba32(), even if autocomplete
    // doesn't find the latter.
// Function to retrieve RGBA32 texture data as a numpy array
    auto font_atlas_get_tex_data_as_rgba32 = [](ImFontAtlas* self) -> nb::handle
    {
        unsigned char *pixels = nullptr;
        int width = 0, height = 0, bytes_per_pixel = 0;

        // Retrieve texture data from ImFontAtlas
        self->GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);

        if (!pixels || width <= 0 || height <= 0 || bytes_per_pixel != 4)
            throw std::runtime_error("Invalid texture data retrieved from ImFontAtlas.");

        // The returned data is a pointer to the texture data, which is owned by the ImFontAtlas.
        // so, we set the owner to the ImFontAtlas object to ensure that the data is not deallocated
        nb::object owner = nb::cast(self);

        // Create and return the ndarray using the initializer list constructor
        // We will use this constructor:
        auto font_as_array = nb::ndarray<uint8_t>(
            pixels,                  // VoidPtr data
            {(size_t)height, (size_t)width, (size_t)4},      // Shape
            owner,                  // Owner
            {(int64_t)(4 * width), (int64_t)4, (int64_t)1},       // Strides in **elements** (not bytes)
            nb::dtype<uint8_t>(),    // Data type
            0,                       // device_type (default to CPU)
            0,                       // device_id (default to 0)
            'C'                      // Order ('C' for C-contiguous)
        );

        // Properly export the ndarray
        return nb::detail::ndarray_export(
            font_as_array.handle(),
            nb::numpy::value,
            nb::rv_policy::move, // Transfer ownership to Python (which will manage the lifetime of the ndarray, and the capsule will manage the lifetime of the data)
            nullptr // cleanup
        );
    };
    m.def("font_atlas_get_tex_data_as_rgba32", font_atlas_get_tex_data_as_rgba32);
    pyClassImFontAtlas.def("get_tex_data_as_rgba32", font_atlas_get_tex_data_as_rgba32);

    //
    //  Other patches
    //

    // VERTEX_SIZE, VERTEX_BUFFER_POS_OFFSET, VERTEX_BUFFER_UV_OFFSET, etc.
    // Utilities to facilitate rendering in python backends: they provide buffer offsets info
    //
    //    def _py_vertex_buffer_vertex_size():
    //    return sizeof(cimgui.ImDrawVert)
    m.attr("VERTEX_SIZE") = sizeof(ImDrawVert);
    //    def _py_vertex_buffer_vertex_pos_offset():
    //    return <uintptr_t><size_t>&(<cimgui.ImDrawVert*>NULL).pos
    ImDrawVert* nullDrawVert = NULL;
    m.attr("VERTEX_BUFFER_POS_OFFSET") = (uintptr_t)(size_t) (& (nullDrawVert->pos));
    //    def _py_vertex_buffer_vertex_uv_offset():
    //    return <uintptr_t><size_t>&(<cimgui.ImDrawVert*>NULL).uv
    m.attr("VERTEX_BUFFER_UV_OFFSET") = (uintptr_t)(size_t) (& (nullDrawVert->uv));
    //    def _py_vertex_buffer_vertex_col_offset():
    //    return <uintptr_t><size_t>&(<cimgui.ImDrawVert*>NULL).col
    m.attr("VERTEX_BUFFER_COL_OFFSET") = (uintptr_t)(size_t) (& (nullDrawVert->col));
    //    def _py_index_buffer_index_size():
    //    return sizeof(cimgui.ImDrawIdx)
    m.attr("INDEX_SIZE") = sizeof(ImDrawIdx);


    m.def("IM_COL32", [](int r, int g, int b, int a){
       return IM_COL32(r, g, b, a);
    });

    // API for imgui_demo
    // ------------------
    // Forward declarations of imgui_demo.cpp API
    void SetImGuiDemoWindowPos(ImVec2 pos, ImVec2 size, ImGuiCond cond);
    void SetImGuiDemoCodeWindowPos(ImVec2 pos, ImVec2 size, ImGuiCond cond);
    void ImGuiDemoSetShowPythonCode(bool showPythonCode);
    extern bool GImGuiDemoMarker_IsActive;
    // Expose imgui_demo.cpp API
    m.def("set_imgui_demo_window_pos", SetImGuiDemoWindowPos);
    m.def("set_imgui_demo_code_window_pos", SetImGuiDemoCodeWindowPos);
    m.def("set_imgui_demo_marker_is_active", [](bool b) { GImGuiDemoMarker_IsActive = b; });
    m.def("get_imgui_demo_marker_is_active", []() { return GImGuiDemoMarker_IsActive; });
    m.def("set_imgui_demo_show_python_code", ImGuiDemoSetShowPythonCode);
}
